!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	qualified	/Include an extra class-qualified tag entry for each tag/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	access	/Access (or export) of class members/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	inherits	/Inheritance information/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	signature	/Signature of routine (e.g. prototype or parameter list)/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	p,prototype	/function prototypes/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/konrad/Documents/GitHub/etr_supplement/ETR/include/etr_bits/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/e4cb2a0f9/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
ACosinus	UtilsTraits.hpp	/^inline double ACosinus(double obj) { return acos(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
ACosinusTrait	UtilsTraits.hpp	/^struct ACosinusTrait {};$/;"	s	namespace:etr
ASinus	UtilsTraits.hpp	/^inline double ASinus(double obj) { return asin(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
ASinusTrait	UtilsTraits.hpp	/^struct ASinusTrait {};$/;"	s	namespace:etr
ATangens	UtilsTraits.hpp	/^inline double ATangens(double obj) { return atan(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
ATangensTrait	UtilsTraits.hpp	/^struct ATangensTrait {};$/;"	s	namespace:etr
Addition	UtilsTraits.hpp	/^inline double Addition(double l, double r) { return l + r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
AllVars	Derivs.hpp	/^  AllVars(size_t IndepVarIdx_) : IndepVarIdx(IndepVarIdx_) {}$/;"	f	struct:etr::AllVars	access:public	signature:(size_t IndepVarIdx_)
AllVars	Derivs.hpp	/^template <int NBuffer_, int NBorrow_, int NBorrowSEXP_> struct AllVars {$/;"	s	namespace:etr
AllVarsRef	Derivs.hpp	/^  T &AllVarsRef;$/;"	m	struct:etr::VarPointer	typeref:typename:T &	access:public
BINARYOPERATION	binaryCalculations.hpp	/^#define BINARYOPERATION$/;"	d
BUFFER_VECTOR_H	BufferVector.hpp	/^#define BUFFER_VECTOR_H$/;"	d
BaseCalc	UtilsTraits.hpp	/^struct BaseCalc { \/\/ issue: is this used?$/;"	s	namespace:etr
BaseStore	UtilsTraits.hpp	/^  BaseStore() {$/;"	f	struct:etr::BaseStore	access:public	signature:()
BaseStore	UtilsTraits.hpp	/^  BaseStore(BaseStore<T> &&other) noexcept$/;"	f	struct:etr::BaseStore	access:public	signature:(BaseStore<T> && other)
BaseStore	UtilsTraits.hpp	/^  BaseStore(SEXP s) {$/;"	f	struct:etr::BaseStore	access:public	signature:(SEXP s)
BaseStore	UtilsTraits.hpp	/^  BaseStore(const BaseStore<T> &other)$/;"	f	struct:etr::BaseStore	access:public	signature:(const BaseStore<T> & other)
BaseStore	UtilsTraits.hpp	/^  BaseStore(int sz_)$/;"	f	struct:etr::BaseStore	access:public	signature:(int sz_)
BaseStore	UtilsTraits.hpp	/^  BaseStore(size_t r, size_t c) = delete;$/;"	p	struct:etr::BaseStore	access:public	signature:(size_t r,size_t c)
BaseStore	UtilsTraits.hpp	/^  BaseStore(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::BaseStore	access:public	signature:(size_t r,size_t c,const double value)
BaseStore	UtilsTraits.hpp	/^  BaseStore(size_t sz_) : sz(sz_), capacity(static_cast<size_t>(sz_ * 1.15)) {$/;"	f	struct:etr::BaseStore	access:public	signature:(size_t sz_)
BaseStore	UtilsTraits.hpp	/^template <typename T, typename BaseTrait> struct BaseStore {$/;"	s	namespace:etr
BaseStoreTrait	UtilsTraits.hpp	/^struct BaseStoreTrait {};$/;"	s	namespace:etr
BaseType	UtilsTraits.hpp	/^typedef double BaseType;$/;"	t	namespace:etr	typeref:typename:double
BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const BinaryOperation &&other)$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const BinaryOperation && other)
BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const BinaryOperation &other)$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const BinaryOperation & other)
BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const BinaryOperation<LType, RType, TraitOther>$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const BinaryOperation<LType,RType,TraitOther> & other)
BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const L &l_, const R &r_, const MatrixParameter &mp_)$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const L & l_,const R & r_,const MatrixParameter & mp_)
BinaryOperation	binaryCalculations.hpp	/^struct BinaryOperation {$/;"	s	namespace:etr
BinaryTrait	UtilsTraits.hpp	/^struct BinaryTrait {$/;"	s	namespace:etr
BinaryType	Derivs.hpp	/^struct BinaryType {$/;"	s	namespace:etr
BoolConstant	UtilsTraits.hpp	/^template <bool B> using BoolConstant = std::integral_constant<bool, B>;$/;"	t	namespace:etr	typeref:typename:std::integral_constant<bool,B>
BoolTrait	UtilsTraits.hpp	/^struct BoolTrait {};$/;"	s	namespace:etr
Borrow	UtilsTraits.hpp	/^  Borrow(){};$/;"	f	struct:etr::Borrow	access:public	signature:()
Borrow	UtilsTraits.hpp	/^  Borrow(Borrow<T> &&other) noexcept$/;"	f	struct:etr::Borrow	access:public	signature:(Borrow<T> && other)
Borrow	UtilsTraits.hpp	/^  Borrow(SEXP s) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(SEXP s)
Borrow	UtilsTraits.hpp	/^  Borrow(T *p, size_t sz) {$/;"	f	struct:etr::Borrow	access:public	signature:(T * p,size_t sz)
Borrow	UtilsTraits.hpp	/^  Borrow(const Borrow<T> &other)$/;"	f	struct:etr::Borrow	access:public	signature:(const Borrow<T> & other)
Borrow	UtilsTraits.hpp	/^  Borrow(int i) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(int i)
Borrow	UtilsTraits.hpp	/^  Borrow(size_t i){};$/;"	f	struct:etr::Borrow	access:public	signature:(size_t i)
Borrow	UtilsTraits.hpp	/^  Borrow(size_t r, size_t c) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(size_t r,size_t c)
Borrow	UtilsTraits.hpp	/^  Borrow(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(size_t r,size_t c,const double value)
Borrow	UtilsTraits.hpp	/^template <typename T, typename BorrowTrait> struct Borrow {$/;"	s	namespace:etr
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP() {}$/;"	f	struct:etr::BorrowSEXP	access:public	signature:()
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(SEXP inp) {$/;"	f	struct:etr::BorrowSEXP	access:public	signature:(SEXP inp)
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(const BorrowSEXP<T> &other) {$/;"	f	struct:etr::BorrowSEXP	access:public	signature:(const BorrowSEXP<T> & other)
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(int i) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(int i)
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(size_t i) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(size_t i)
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(size_t r, size_t c) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(size_t r,size_t c)
BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(size_t r,size_t c,const double value)
BorrowSEXP	UtilsTraits.hpp	/^template <typename T, typename BorrowSEXPSEXPTrait> struct BorrowSEXP {$/;"	s	namespace:etr
BorrowSEXPTrait	UtilsTraits.hpp	/^struct BorrowSEXPTrait {};$/;"	s	namespace:etr
BorrowTrait	UtilsTraits.hpp	/^struct BorrowTrait {};$/;"	s	namespace:etr
Buffer	BufferVector.hpp	/^struct Buffer : public BaseStore<T> {$/;"	s	namespace:etr	inherits:BaseStore<T>
BufferTrait	UtilsTraits.hpp	/^struct BufferTrait {};$/;"	s	namespace:etr
CaseTrait	BufferVector.hpp	/^    using CaseTrait = Trait2;$/;"	t	function:etr::Vec::Vec	typeref:typename:Trait2
CaseTrait	BufferVector.hpp	/^  using CaseTrait = CTrait;$/;"	t	struct:etr::Buffer	typeref:typename:CTrait	access:public
CaseTrait	BufferVector.hpp	/^  using CaseTrait = Trait;$/;"	t	struct:etr::Vec	typeref:typename:Trait	access:public
CaseTrait	Derivs.hpp	/^  using CaseTrait = Trait;$/;"	t	struct:etr::VarPointer	typeref:typename:Trait	access:public
CaseTrait	UtilsTraits.hpp	/^  typename T::CaseTrait;$/;"	m	class:etr::T	typeref:meta:typename
CaseTrait	UtilsTraits.hpp	/^  typename std::remove_reference<decltype(t)>::type::CaseTrait;$/;"	m	class:etr::std::remove_reference<decltype(t)>::type	typeref:meta:typename
CaseTrait	UtilsTraits.hpp	/^  using CaseTrait = BorrowSEXPSEXPTrait;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXPSEXPTrait	access:public
CaseTrait	UtilsTraits.hpp	/^  using CaseTrait = BorrowTrait;$/;"	t	struct:etr::Borrow	typeref:typename:BorrowTrait	access:public
CaseTrait	UtilsTraits.hpp	/^  using CaseTrait = SubsetTrait;$/;"	t	struct:etr::Subset	typeref:typename:SubsetTrait	access:public
CaseTrait	binaryCalculations.hpp	/^  using CaseTrait = BinaryTrait;$/;"	t	struct:etr::BinaryOperation	typeref:typename:BinaryTrait	access:public
CaseTrait	unaryCalculations.hpp	/^  using CaseTrait = CTrait;$/;"	t	struct:etr::UnaryOperation	typeref:typename:CTrait	access:public
CommonType	UtilsTraits.hpp	/^typename std::common_type<T1, T2>::type CommonType(T1 arg1, T2 arg2) {$/;"	f	namespace:etr	typeref:typename:std::common_type<T1,T2>::type	signature:(T1 arg1,T2 arg2)
ComparisonTrait	UtilsTraits.hpp	/^struct ComparisonTrait {$/;"	s	namespace:etr
Cosinus	UtilsTraits.hpp	/^inline double Cosinus(double obj) { return cos(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
CosinusH	UtilsTraits.hpp	/^inline double CosinusH(double obj) { return cosh(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
CosinusHTrait	UtilsTraits.hpp	/^struct CosinusHTrait {};$/;"	s	namespace:etr
CosinusTrait	UtilsTraits.hpp	/^struct CosinusTrait {};$/;"	s	namespace:etr
CurrentBaseType	UtilsTraits.hpp	/^  using CurrentBaseType = std::remove_reference<decltype(*p)>::type::Type;$/;"	t	struct:etr::Subset	access:public
DERIVS_H	Derivs.hpp	/^#define DERIVS_H$/;"	d
DISTRI	distri.hpp	/^#define DISTRI$/;"	d
DType	BufferVector.hpp	/^  using DType = R;$/;"	t	struct:etr::Vec	typeref:typename:R	access:public
DataType	helper.hpp	/^  using DataType = ExtractDataType<L>::type;$/;"	t	function:etr::rep	typeref:typename:ExtractDataType<L>::type
Derivs	Derivs.hpp	/^  std::array<Buffer<BaseType>, NBuffer + NBorrow + NBorrowSEXP> Derivs;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Buffer<BaseType>,NBuffer+NBorrow+NBorrowSEXP>	access:public
Divide	UtilsTraits.hpp	/^inline double Divide(double l, double r) { return l \/ r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
DivideTrait	UtilsTraits.hpp	/^struct DivideTrait {$/;"	s	namespace:etr
DoubleTrait	UtilsTraits.hpp	/^struct DoubleTrait {};$/;"	s	namespace:etr
Equal	UtilsTraits.hpp	/^inline double Equal(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
EqualTrait	UtilsTraits.hpp	/^struct EqualTrait {$/;"	s	namespace:etr
Exp	UtilsTraits.hpp	/^inline double Exp(double obj) { return exp(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
ExpTrait	UtilsTraits.hpp	/^struct ExpTrait {};$/;"	s	namespace:etr
ExtractDType	Derivs.hpp	/^struct ExtractDType<Vec<T, R, Trait>> {$/;"	s	namespace:etr
ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<Buffer<T, R, Trait>> {$/;"	s	namespace:etr
ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<Vec<T, R, Trait>> {$/;"	s	namespace:etr
ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<const Buffer<T, R, Trait>> {$/;"	s	namespace:etr
ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<const Vec<T, R, Trait>> {$/;"	s	namespace:etr
ExtractTypeD	Derivs.hpp	/^struct ExtractTypeD<Vec<T, R, Trait>> {$/;"	s	namespace:etr
ExtractTypeD	Derivs.hpp	/^struct ExtractTypeD<const Vec<T, R, Trait>> {$/;"	s	namespace:etr
ExtractTypeTrait	Derivs.hpp	/^struct ExtractTypeTrait<VarPointer<T, Idx, TypeTrait>> {$/;"	s	namespace:etr
ExtractTypeTrait	Derivs.hpp	/^struct ExtractTypeTrait<const VarPointer<T, Idx, TypeTrait> &> {$/;"	s	namespace:etr
ExtractTypeTrait	Derivs.hpp	/^template <typename T> struct ExtractTypeTrait {$/;"	s	namespace:etr
ExtractedDType	Derivs.hpp	/^template <typename T> using ExtractedDType = typename ExtractDType<T>::type;$/;"	t	namespace:etr	typeref:typename:ExtractDType<T>::type
ExtractedTypeD	Derivs.hpp	/^template <typename T> using ExtractedTypeD = typename ExtractTypeD<T>::type;$/;"	t	namespace:etr	typeref:typename:ExtractTypeD<T>::type
ExtractedTypeData	UtilsTraits.hpp	/^using ExtractedTypeData = typename ExtractDataType<T>::RetType;$/;"	t	namespace:etr	typeref:typename:ExtractDataType<T>::RetType
ExtractedTypeTrait	Derivs.hpp	/^using ExtractedTypeTrait = typename ExtractTypeTrait<T>::type;$/;"	t	namespace:etr	typeref:typename:ExtractTypeTrait<T>::type
F	UtilsTraits.hpp	/^using F = BoolConstant<false>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<false>
FALSE	UtilsTraits.hpp	/^using FALSE = BoolConstant<false>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<false>
HELPER_H	helper.hpp	/^#define HELPER_H$/;"	d
I	Derivs.hpp	/^  static constexpr int I = Idx;$/;"	m	struct:etr::VarPointer	typeref:typename:int	access:public
INTERPOLATION_H	interpolation.hpp	/^#define INTERPOLATION_H$/;"	d
ISNA	helper.hpp	/^bool ISNA(T inp) {$/;"	f	namespace:etr	typeref:typename:bool	signature:(T inp)
IndepVarIdx	Derivs.hpp	/^  size_t IndepVarIdx = 0;$/;"	m	struct:etr::AllVars	typeref:typename:size_t	access:public
Indices	UtilsTraits.hpp	/^struct Indices : public BaseStore<size_t> {$/;"	s	namespace:etr	inherits:BaseStore<size_t>
IntTrait	UtilsTraits.hpp	/^struct IntTrait {};$/;"	s	namespace:etr
It	UtilsTraits.hpp	/^template <typename T> struct It {$/;"	s	namespace:etr
Larger	UtilsTraits.hpp	/^inline double Larger(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
LargerEqual	UtilsTraits.hpp	/^inline double LargerEqual(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
LargerEqualTrait	UtilsTraits.hpp	/^struct LargerEqualTrait {$/;"	s	namespace:etr
LargerTrait	UtilsTraits.hpp	/^struct LargerTrait {$/;"	s	namespace:etr
Log	UtilsTraits.hpp	/^inline double Log(double obj) { return log(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
LogTrait	UtilsTraits.hpp	/^struct LogTrait {};$/;"	s	namespace:etr
LoopVariadicT	Derivs.hpp	/^template <class F, class... Args> inline F LoopVariadicT(F f, Args &&...args) {$/;"	f	namespace:etr	typeref:typename:F	signature:(F f,Args &&...args)
MatrixParameter	UtilsTraits.hpp	/^  MatrixParameter() {}$/;"	f	struct:etr::MatrixParameter	access:public	signature:()
MatrixParameter	UtilsTraits.hpp	/^  MatrixParameter(const MatrixParameter &other)$/;"	f	struct:etr::MatrixParameter	access:public	signature:(const MatrixParameter & other)
MatrixParameter	UtilsTraits.hpp	/^  MatrixParameter(size_t rows_, size_t cols_)$/;"	f	struct:etr::MatrixParameter	access:public	signature:(size_t rows_,size_t cols_)
MatrixParameter	UtilsTraits.hpp	/^struct MatrixParameter {$/;"	s	namespace:etr
Minus	UtilsTraits.hpp	/^inline double Minus(double l, double r) { return l - r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
MinusTrait	UtilsTraits.hpp	/^struct MinusTrait {$/;"	s	namespace:etr
MinusUnary	UtilsTraits.hpp	/^inline double MinusUnary(double obj) { return -obj; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
MinusUnaryTrait	UtilsTraits.hpp	/^struct MinusUnaryTrait {};$/;"	s	namespace:etr
NA_REAL	UtilsTraits.hpp	/^const double NA_REAL = std::numeric_limits<double>::quiet_NaN();$/;"	v	namespace:etr	typeref:typename:const double
NBorrow	Derivs.hpp	/^  static constexpr int NBorrow = NBorrow_;$/;"	m	struct:etr::AllVars	typeref:typename:int	access:public
NBorrowSEXP	Derivs.hpp	/^  static constexpr int NBorrowSEXP = NBorrowSEXP_;$/;"	m	struct:etr::AllVars	typeref:typename:int	access:public
NBuffer	Derivs.hpp	/^  static constexpr int NBuffer = NBuffer_;$/;"	m	struct:etr::AllVars	typeref:typename:int	access:public
Op	Derivs.hpp	/^  using Op = OpTrait;$/;"	t	struct:etr::BinaryType	typeref:typename:OpTrait	access:public
PRINT_STREAM	helper.hpp	/^#define PRINT_STREAM /;"	d
PRINT_STREAM	helper.hpp	/^#define PRINT_STREAM PRINT_STREAM$/;"	d
PlusDeriv	UtilsTraits.hpp	/^inline double PlusDeriv(double lDeriv, double rDeriv) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double lDeriv,double rDeriv)
PlusDerivTrait	UtilsTraits.hpp	/^template <typename L, typename R> struct PlusDerivTrait {$/;"	s	namespace:etr
PlusTrait	UtilsTraits.hpp	/^struct PlusTrait {$/;"	s	namespace:etr
Pow	UtilsTraits.hpp	/^inline double Pow(double l, double r) { return std::pow(l, r); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
PowTrait	UtilsTraits.hpp	/^struct PowTrait {$/;"	s	namespace:etr
QuarternaryTrait	UtilsTraits.hpp	/^struct QuarternaryTrait {$/;"	s	namespace:etr
QuarternyType	Derivs.hpp	/^struct QuarternyType {$/;"	s	namespace:etr
RBufTrait	UtilsTraits.hpp	/^struct RBufTrait {};$/;"	s	namespace:etr
RVecTrait	UtilsTraits.hpp	/^struct RVecTrait {};$/;"	s	namespace:etr
R_FINITE	helper.hpp	/^bool R_FINITE(T inp) {$/;"	f	namespace:etr	typeref:typename:bool	signature:(T inp)
R_PosInf	UtilsTraits.hpp	/^const double R_PosInf = std::numeric_limits<double>::infinity();$/;"	v	namespace:etr	typeref:typename:const double
RetType	BufferVector.hpp	/^  using RetType = T; \/\/ BaseType;$/;"	t	struct:etr::Buffer	typeref:typename:T	access:public
RetType	BufferVector.hpp	/^  using RetType = std::remove_reference<decltype(d)>::type::RetType;$/;"	t	struct:etr::Vec	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::BinaryTrait	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::Borrow	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::QuarternaryTrait	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::SinusDerivTrait	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::Subset	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::TimesDerivTrait	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::UnaryTrait	typeref:typename:BaseType	access:public
RetType	UtilsTraits.hpp	/^  using RetType = T const;$/;"	t	struct:etr::ExtractDataType	typeref:typename:T const	access:public
RetType	UtilsTraits.hpp	/^  using RetType = T;$/;"	t	struct:etr::BaseStore	typeref:typename:T	access:public
RetType	UtilsTraits.hpp	/^  using RetType = T;$/;"	t	struct:etr::ExtractDataType	typeref:typename:T	access:public
RetType	UtilsTraits.hpp	/^  using RetType = bool;$/;"	t	struct:etr::ComparisonTrait	typeref:typename:bool	access:public
RetType	UtilsTraits.hpp	/^  using RetType = decltype(CommonType<L, R>);$/;"	t	struct:etr::PlusDerivTrait	access:public
RetType	UtilsTraits.hpp	/^  using RetType = size_t;$/;"	t	struct:etr::Indices	typeref:typename:size_t	access:public
RetType	binaryCalculations.hpp	/^  using RetType = typename CTrait::RetType;$/;"	t	struct:etr::BinaryOperation	typeref:typename:CTrait::RetType	access:public
RetType	unaryCalculations.hpp	/^  using RetType = typename CTrait::RetType;$/;"	t	struct:etr::UnaryOperation	typeref:typename:CTrait::RetType	access:public
RetTypeOtherVec	BufferVector.hpp	/^      using RetTypeOtherVec =$/;"	t	function:etr::Vec::operator =
SUBSETTING	subsetting.hpp	/^#define SUBSETTING$/;"	d
Sinus	UtilsTraits.hpp	/^inline double Sinus(double obj) { return sin(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
SinusDerivTrait	UtilsTraits.hpp	/^struct SinusDerivTrait {$/;"	s	namespace:etr
SinusH	UtilsTraits.hpp	/^inline double SinusH(double obj) { return sinh(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
SinusHTrait	UtilsTraits.hpp	/^struct SinusHTrait {};$/;"	s	namespace:etr
SinusTrait	UtilsTraits.hpp	/^struct SinusTrait {};$/;"	s	namespace:etr
Smaller	UtilsTraits.hpp	/^inline double Smaller(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
SmallerEqual	UtilsTraits.hpp	/^inline double SmallerEqual(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
SmallerEqualTrait	UtilsTraits.hpp	/^struct SmallerEqualTrait {$/;"	s	namespace:etr
SmallerTrait	UtilsTraits.hpp	/^struct SmallerTrait {$/;"	s	namespace:etr
SquareRoot	UtilsTraits.hpp	/^inline double SquareRoot(double obj) { return sqrt(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
SquareRootTrait	UtilsTraits.hpp	/^struct SquareRootTrait {};$/;"	s	namespace:etr
Subset	UtilsTraits.hpp	/^  Subset() = delete;$/;"	p	struct:etr::Subset	access:public	signature:()
Subset	UtilsTraits.hpp	/^  Subset(SEXP) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(SEXP)
Subset	UtilsTraits.hpp	/^  Subset(const Subset &&other) {$/;"	f	struct:etr::Subset	access:public	signature:(const Subset && other)
Subset	UtilsTraits.hpp	/^  Subset(const Subset &other) {$/;"	f	struct:etr::Subset	access:public	signature:(const Subset & other)
Subset	UtilsTraits.hpp	/^  Subset(const Vec<T2, R2, TraitOther> &other) {$/;"	f	struct:etr::Subset	access:public	signature:(const Vec<T2,R2,TraitOther> & other)
Subset	UtilsTraits.hpp	/^  Subset(int i) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(int i)
Subset	UtilsTraits.hpp	/^  Subset(size_t i) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(size_t i)
Subset	UtilsTraits.hpp	/^  Subset(size_t r, size_t c) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(size_t r,size_t c)
Subset	UtilsTraits.hpp	/^  Subset(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(size_t r,size_t c,const double value)
Subset	UtilsTraits.hpp	/^  template <typename T2, typename R2> Subset(Vec<T2, R2> &other) {$/;"	f	struct:etr::Subset	access:public	signature:(Vec<T2,R2> & other)
Subset	UtilsTraits.hpp	/^template <typename T, typename SubsetTrait> struct Subset {$/;"	s	namespace:etr
SubsetTrait	UtilsTraits.hpp	/^struct SubsetTrait {};$/;"	s	namespace:etr
T	Derivs.hpp	/^  using T = std::remove_const_t<std::remove_reference_t<TRaw>>;$/;"	t	function:etr::walkT	typeref:typename:std::remove_const_t<std::remove_reference_t<TRaw>>
T	Derivs.hpp	/^  using T = std::remove_reference_t<TRaw>;$/;"	t	function:etr::produceVariableType	typeref:typename:std::remove_reference_t<TRaw>
T	UtilsTraits.hpp	/^using T = BoolConstant<true>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<true>
TRUE	UtilsTraits.hpp	/^using TRUE = BoolConstant<true>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<true>
Tangens	UtilsTraits.hpp	/^inline double Tangens(double obj) { return tan(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
TangensH	UtilsTraits.hpp	/^inline double TangensH(double obj) { return tanh(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
TangensHTrait	UtilsTraits.hpp	/^struct TangensHTrait {};$/;"	s	namespace:etr
TangensTrait	UtilsTraits.hpp	/^struct TangensTrait {};$/;"	s	namespace:etr
Times	UtilsTraits.hpp	/^inline double Times(double l, double r) { return l * r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
TimesDeriv	UtilsTraits.hpp	/^inline double TimesDeriv(double l, double r, double lDeriv, double rDeriv) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r,double lDeriv,double rDeriv)
TimesDerivTrait	UtilsTraits.hpp	/^struct TimesDerivTrait {$/;"	s	namespace:etr
TimesTrait	UtilsTraits.hpp	/^struct TimesTrait {$/;"	s	namespace:etr
Ty	Derivs.hpp	/^    using Ty = typename std::remove_reference<Type>::type;$/;"	t	function:etr::VariableType::getDeriv	typeref:typename:std::remove_reference<Type>::type
Ty	Derivs.hpp	/^    using Ty = typename std::remove_reference<Type>::type;$/;"	t	function:etr::VariableType::getSize	typeref:typename:std::remove_reference<Type>::type
Ty	Derivs.hpp	/^    using Ty = typename std::remove_reference<Type>::type;$/;"	t	function:etr::VariableType::getVal	typeref:typename:std::remove_reference<Type>::type
Ty	unaryCalculations.hpp	/^    using Ty = typename std::remove_reference<typeTraitObj>::type;$/;"	t	function:etr::UnaryOperation::getSize	typeref:typename:std::remove_reference<typeTraitObj>::type
Ty	unaryCalculations.hpp	/^    using Ty = typename std::remove_reference<typeTraitObj>::type;$/;"	t	function:etr::UnaryOperation::getVal	typeref:typename:std::remove_reference<typeTraitObj>::type
TyL	binaryCalculations.hpp	/^    using TyL = typename std::remove_reference<typeTraitL>::type;$/;"	t	function:etr::BinaryOperation::getSize	typeref:typename:std::remove_reference<typeTraitL>::type
TyL	binaryCalculations.hpp	/^    using TyL = typename std::remove_reference<typeTraitL>::type;$/;"	t	function:etr::BinaryOperation::getVal	typeref:typename:std::remove_reference<typeTraitL>::type
TyR	binaryCalculations.hpp	/^    using TyR = typename std::remove_reference<typeTraitR>::type;$/;"	t	function:etr::BinaryOperation::getSize	typeref:typename:std::remove_reference<typeTraitR>::type
TyR	binaryCalculations.hpp	/^    using TyR = typename std::remove_reference<typeTraitR>::type;$/;"	t	function:etr::BinaryOperation::getVal	typeref:typename:std::remove_reference<typeTraitR>::type
Type	BufferVector.hpp	/^  using Type = T;$/;"	t	struct:etr::Vec	typeref:typename:T	access:public
Type	Derivs.hpp	/^  using Type = T;$/;"	t	struct:etr::VariableType	typeref:typename:T	access:public
Type	UtilsTraits.hpp	/^  typename R::Type;$/;"	m	class:etr::R	typeref:meta:typename
Type	UtilsTraits.hpp	/^  using Type = DoubleTrait;$/;"	t	struct:etr::doubleWrapper	typeref:typename:DoubleTrait	access:public
Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::BaseStore	typeref:typename:T	access:public
Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::Borrow	typeref:typename:T	access:public
Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:T	access:public
Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::Subset	typeref:typename:T	access:public
Type	binaryCalculations.hpp	/^  using Type = DoubleTrait;$/;"	t	struct:etr::BinaryOperation	typeref:typename:DoubleTrait	access:public
TypeTrait	BufferVector.hpp	/^    using TypeTrait = OperationTrait;$/;"	t	function:etr::Vec::Vec	typeref:typename:OperationTrait
TypeTrait	BufferVector.hpp	/^    using TypeTrait = Trait2;$/;"	t	function:etr::Vec::Vec	typeref:typename:Trait2
TypeTrait	BufferVector.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::Buffer	typeref:typename:Trait	access:public
TypeTrait	BufferVector.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::Vec	typeref:typename:Trait	access:public
TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::BinaryType	typeref:typename:Trait	access:public
TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::QuarternyType	typeref:typename:Trait	access:public
TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::UnaryType	typeref:typename:Trait	access:public
TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::VarPointer	typeref:typename:Trait	access:public
TypeTrait	Derivs.hpp	/^  using TypeTrait = VariableTypeTrait;$/;"	t	struct:etr::VariableType	typeref:typename:VariableTypeTrait	access:public
TypeTrait	UtilsTraits.hpp	/^  typename R::TypeTrait;$/;"	m	class:etr::R	typeref:meta:typename
TypeTrait	UtilsTraits.hpp	/^  typename std::remove_reference<decltype(t)>::type::TypeTrait;$/;"	m	class:etr::std::remove_reference<decltype(t)>::type	typeref:meta:typename
TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = BaseTrait;$/;"	t	struct:etr::BaseStore	typeref:typename:BaseTrait	access:public
TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = BorrowSEXPSEXPTrait;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXPSEXPTrait	access:public
TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = BorrowTrait;$/;"	t	struct:etr::Borrow	typeref:typename:BorrowTrait	access:public
TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = SubsetTrait;$/;"	t	struct:etr::Subset	typeref:typename:SubsetTrait	access:public
TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::doubleWrapper	typeref:typename:Trait	access:public
TypeTrait	binaryCalculations.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::BinaryOperation	typeref:typename:Trait	access:public
TypeTrait	unaryCalculations.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::UnaryOperation	typeref:typename:Trait	access:public
UNARYOPERATION	unaryCalculations.hpp	/^#define UNARYOPERATION$/;"	d
UTILSTRAITS_H	UtilsTraits.hpp	/^#define UTILSTRAITS_H$/;"	d
UnEqual	UtilsTraits.hpp	/^inline double UnEqual(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
UnEqualTrait	UtilsTraits.hpp	/^struct UnEqualTrait {$/;"	s	namespace:etr
UnaryFct	UtilsTraits.hpp	/^typedef double (*UnaryFct)(double);$/;"	t	namespace:etr	typeref:typename:double (*)(double)
UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const I &obj_, const MatrixParameter &mp)$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const I & obj_,const MatrixParameter & mp)
UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const UnaryOperation &&other) : obj(other.obj), mp(other.mp) {}$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const UnaryOperation && other)
UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const UnaryOperation &other) : obj(other.obj), mp(other.mp) {}$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const UnaryOperation & other)
UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const UnaryOperation<IType, fOther, TraitOther> &other)$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const UnaryOperation<IType,fOther,TraitOther> & other)
UnaryOperation	unaryCalculations.hpp	/^struct UnaryOperation {$/;"	s	namespace:etr
UnaryTrait	UtilsTraits.hpp	/^struct UnaryTrait {$/;"	s	namespace:etr
UnaryType	Derivs.hpp	/^template <typename Deriv, typename Trait, typename OpTrait> struct UnaryType {$/;"	s	namespace:etr
VarPointer	Derivs.hpp	/^  VarPointer(T &AllVars_) : AllVarsRef(AllVars_) {}$/;"	f	struct:etr::VarPointer	access:public	signature:(T & AllVars_)
VarPointer	Derivs.hpp	/^struct VarPointer {$/;"	s	namespace:etr
VarPointerTrait	Derivs.hpp	/^struct VarPointerTrait {};$/;"	s	namespace:etr
VarSizes	Derivs.hpp	/^  std::array<size_t, NBuffer + NBorrow + NBorrowSEXP> VarSizes;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<size_t,NBuffer+NBorrow+NBorrowSEXP>	access:public
VariableTrait	UtilsTraits.hpp	/^struct VariableTrait {};$/;"	s	namespace:etr
VariableType	Derivs.hpp	/^template <typename T> struct VariableType {$/;"	s	namespace:etr
VariableTypeTrait	Derivs.hpp	/^struct VariableTypeTrait {};$/;"	s	namespace:etr
Vec	BufferVector.hpp	/^                                                     explicit Vec(size_t sz)$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,BorrowSEXP<BaseType>>	access:public	signature:(size_t sz)
Vec	BufferVector.hpp	/^  Vec(BaseType *ptr, size_t rows, size_t cols) : d(rows * cols) {$/;"	f	struct:etr::Vec	access:public	signature:(BaseType * ptr,size_t rows,size_t cols)
Vec	BufferVector.hpp	/^  Vec(BaseType *ptr, size_t size) : d(size) {$/;"	f	struct:etr::Vec	access:public	signature:(BaseType * ptr,size_t size)
Vec	BufferVector.hpp	/^  Vec(Rboolean b) : d(1) {$/;"	f	struct:etr::Vec	access:public	signature:(Rboolean b)
Vec	BufferVector.hpp	/^  Vec(Rcpp::NumericMatrix otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(Rcpp::NumericMatrix otherVec)
Vec	BufferVector.hpp	/^  Vec(Rcpp::NumericVector otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(Rcpp::NumericVector otherVec)
Vec	BufferVector.hpp	/^  Vec(arma::mat otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(arma::mat otherVec)
Vec	BufferVector.hpp	/^  Vec(arma::vec otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(arma::vec otherVec)
Vec	BufferVector.hpp	/^  Vec(bool b) : d(1) { d[0] = static_cast<BaseType>(b); }$/;"	f	struct:etr::Vec	access:public	signature:(bool b)
Vec	BufferVector.hpp	/^  Vec(const Vec<T2, R2, Trait2> &other_vec) { \/\/ : d()$/;"	f	struct:etr::Vec	access:public	signature:(const Vec<T2,R2,Trait2> & other_vec)
Vec	BufferVector.hpp	/^  Vec(const Vec<T2, R2, Trait2>$/;"	f	struct:etr::Vec	access:public	signature:(const Vec<T2,R2,Trait2> && other_vec)
Vec	BufferVector.hpp	/^  Vec(double sz) : d(1) {$/;"	f	struct:etr::Vec	access:public	signature:(double sz)
Vec	BufferVector.hpp	/^  explicit Vec($/;"	f	struct:etr::Vec	access:public	signature:(const BinaryOperation<L2,R2,OperationTrait,DetailTrait> && inp)
Vec	BufferVector.hpp	/^  explicit Vec() : d() {}$/;"	f	struct:etr::Vec	access:public	signature:()
Vec	BufferVector.hpp	/^  explicit Vec(BinaryOperation<L2, R2, OperationTrait> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(BinaryOperation<L2,R2,OperationTrait> & inp)
Vec	BufferVector.hpp	/^  explicit Vec(T *ptr, size_t s) : d(ptr, s) {}$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,Borrow<T>>	access:public	signature:(T * ptr,size_t s)
Vec	BufferVector.hpp	/^  explicit Vec(UnaryOperation<L2, f, OperationTrait> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(UnaryOperation<L2,f,OperationTrait> & inp)
Vec	BufferVector.hpp	/^  explicit Vec(const BinaryOperation<L2, R2, OperationTrait> &&inp)$/;"	f	struct:etr::Vec	access:public	signature:(const BinaryOperation<L2,R2,OperationTrait> && inp)
Vec	BufferVector.hpp	/^  explicit Vec(const Borrow<T2> &&borrowed) : d(borrowed) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,Borrow<BaseType>>	access:public	signature:(const Borrow<T2> && borrowed)
Vec	BufferVector.hpp	/^  explicit Vec(const Borrow<T2> &borrowed) : d(borrowed) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,Borrow<T>>	access:public	signature:(const Borrow<T2> & borrowed)
Vec	BufferVector.hpp	/^  explicit Vec(const Buffer<L2, TraitOther> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Buffer<L2,TraitOther> & inp)
Vec	BufferVector.hpp	/^  explicit Vec(const UnaryOperation<L2, f, OperationTrait> &&inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const UnaryOperation<L2,f,OperationTrait> && inp)
Vec	BufferVector.hpp	/^  explicit Vec(const Vec<T2> &other_vec) : d() {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<T2,bool>	access:public	signature:(const Vec<T2> & other_vec)
Vec	BufferVector.hpp	/^  explicit Vec(int sz) : d(static_cast<size_t>(sz)) {}$/;"	f	struct:etr::Vec	access:public	signature:(int sz)
Vec	BufferVector.hpp	/^  explicit Vec(size_t rows, size_t cols) : d(rows * cols) {$/;"	f	struct:etr::Vec	access:public	signature:(size_t rows,size_t cols)
Vec	BufferVector.hpp	/^  explicit Vec(size_t rows, size_t cols, const double value) : d(rows * cols) {$/;"	f	struct:etr::Vec	access:public	signature:(size_t rows,size_t cols,const double value)
Vec	BufferVector.hpp	/^  explicit Vec(size_t sz) : d(sz) {}$/;"	f	struct:etr::Vec	access:public	signature:(size_t sz)
Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(Subset<L2> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(Subset<L2> & inp)
Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(const Buffer<L2> &&inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Buffer<L2> && inp)
Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(const Buffer<L2> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Buffer<L2> & inp)
Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(const Subset<L2> &&inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Subset<L2> && inp)
Vec	BufferVector.hpp	/^  template <typename T2> Vec(T2 n) = delete;$/;"	p	struct:etr::Vec	access:public	signature:(T2 n)
Vec	BufferVector.hpp	/^template <typename T, typename R, typename Trait> struct Vec {$/;"	s	namespace:etr
VectorTrait	UtilsTraits.hpp	/^struct VectorTrait {};$/;"	s	namespace:etr
__anon1c14c11b0102	helper.hpp	/^      [&](auto arg) {$/;"	f	function:etr::coca	file:	signature:(auto arg) 
__anon1c14c11b0202	helper.hpp	/^      [&](auto arg) {$/;"	f	function:etr::coca	file:	signature:(auto arg) 
__anon210577a80102	Derivs.hpp	/^        [&](auto arg) {$/;"	f	function:etr::AllVars::initBuffer	file:	signature:(auto arg) 
__anon210577a80202	Derivs.hpp	/^        [&](auto arg) {$/;"	f	function:etr::AllVars::initBorrow	file:	signature:(auto arg) 
__anon210577a80302	Derivs.hpp	/^        [&](auto arg) {$/;"	f	function:etr::AllVars::initBorrowSEXP	file:	signature:(auto arg) 
acosinus	unaryCalculations.hpp	/^auto acosinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
acosinus	unaryCalculations.hpp	/^auto acosinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,ACosinus,ACosinusTrait>,UnaryTrait>	signature:(const T & obj)
add	Derivs.hpp	/^auto add(const L &l, const R &r) { \/\/ issue: check for scalar. And do what?$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
allocated	UtilsTraits.hpp	/^  bool allocated = false;$/;"	m	struct:etr::BaseStore	typeref:typename:bool	access:public
allocated	UtilsTraits.hpp	/^  bool allocated = false;$/;"	m	struct:etr::Borrow	typeref:typename:bool	access:public
allocated	UtilsTraits.hpp	/^  bool allocated = false;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:bool	access:public
asinus	unaryCalculations.hpp	/^auto asinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
asinus	unaryCalculations.hpp	/^auto asinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,ASinus,ASinusTrait>,UnaryTrait>	signature:(const T & obj)
ass	UtilsTraits.hpp	/^inline void ass(bool inp, std::string message) {$/;"	f	namespace:etr	typeref:typename:void	signature:(bool inp,std::string message)
at	subsetting.hpp	/^inline BaseType &at(T &inp, R i) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<R,size_t> BaseType &	signature:(T & inp,R i)
at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &&inp, size_t r, size_t c) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> && inp,size_t r,size_t c)
at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, BaseType i_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> & inp,BaseType i_)
at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, BaseType r_, BaseType c_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> & inp,BaseType r_,BaseType c_)
at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, R i) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<R,size_t> BaseType &	signature:(const Vec<BaseType> & inp,R i)
at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, size_t r, size_t c) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> & inp,size_t r,size_t c)
at	subsetting.hpp	/^template <typename T> inline BaseType &at(T &inp, BaseType i_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(T & inp,BaseType i_)
at	subsetting.hpp	/^template <typename T> inline BaseType &at(T &inp, BaseType r_, BaseType c_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(T & inp,BaseType r_,BaseType c_)
at	subsetting.hpp	/^template <typename T> inline BaseType &at(T &inp, size_t r, size_t c) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(T & inp,size_t r,size_t c)
atangens	unaryCalculations.hpp	/^auto atangens(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
atangens	unaryCalculations.hpp	/^auto atangens(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,ATangens,ATangensTrait>,UnaryTrait>	signature:(const T & obj)
b2d	UtilsTraits.hpp	/^inline double b2d(bool inp) { return static_cast<double>(inp); }$/;"	f	namespace:etr	typeref:typename:double	signature:(bool inp)
back	BufferVector.hpp	/^  T &back() const { return d.p[this->size()]; }$/;"	f	struct:etr::Vec	typeref:typename:T &	access:public	signature:() const
back	UtilsTraits.hpp	/^  T &back() { return p[sz]; }$/;"	f	struct:etr::BaseStore	typeref:typename:T &	access:public	signature:()
back	UtilsTraits.hpp	/^  T &back() { return p[sz]; }$/;"	f	struct:etr::Borrow	typeref:typename:T &	access:public	signature:()
back	UtilsTraits.hpp	/^  T &back() { return p[sz]; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:T &	access:public	signature:()
begin	BufferVector.hpp	/^  auto begin() const {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:() const
begin	UtilsTraits.hpp	/^  auto begin() const { return It<T>{p}; }$/;"	f	struct:etr::BaseStore	typeref:typename:auto	access:public	signature:() const
begin	UtilsTraits.hpp	/^  auto begin() const { return It<T>{p}; }$/;"	f	struct:etr::Borrow	typeref:typename:auto	access:public	signature:() const
begin	UtilsTraits.hpp	/^  auto begin() const { return It<T>{p}; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:auto	access:public	signature:() const
binaryFct	UtilsTraits.hpp	/^typedef double (*binaryFct)(double, double);$/;"	t	namespace:etr	typeref:typename:double (*)(double,double)
calcInd	subsetting.hpp	/^inline void calcInd(T &vec, Indices &ind, const I &idx) {$/;"	f	namespace:etr	typeref:typename:void	signature:(T & vec,Indices & ind,const I & idx)
calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires (std::is_same_v<L,int>||std::is_same_v<L,double>)void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires IsVecBool<L> void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires IsVecDouble<L> void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<L,bool> void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
capacity	UtilsTraits.hpp	/^  size_t capacity = 0;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public
capacity	UtilsTraits.hpp	/^  size_t capacity = 1;$/;"	m	struct:etr::BaseStore	typeref:typename:size_t	access:public
capacity	UtilsTraits.hpp	/^  size_t capacity = 1;$/;"	m	struct:etr::Borrow	typeref:typename:size_t	access:public
caseTraitD	BufferVector.hpp	/^  using caseTraitD = std::remove_reference<decltype(d)>::type::CaseTrait;$/;"	t	struct:etr::Vec	access:public
cleanType	Derivs.hpp	/^  using cleanType = std::remove_const_t<std::remove_reference_t<T>>;$/;"	t	function:etr::walkT	typeref:typename:std::remove_const_t<std::remove_reference_t<T>>
cmr	interpolation.hpp	/^inline double cmr(const A &tInp, const B &timeVec, const C &parVec) {$/;"	f	namespace:etr	typeref:typename:double	signature:(const A & tInp,const B & timeVec,const C & parVec)
cmrInternal	interpolation.hpp	/^inline double cmrInternal(const A &tInp, const B &timeVec, const C &parVec) {$/;"	f	namespace:etr	typeref:typename:double	signature:(const A & tInp,const B & timeVec,const C & parVec)
coca	helper.hpp	/^template <typename... Args> inline Vec<BaseType> coca(Args &&...args) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(Args &&...args)
colon	helper.hpp	/^inline Vec<double> colon(const A &start, const O &end) {$/;"	f	namespace:etr	typeref:typename:Vec<double>	signature:(const A & start,const O & end)
cols	UtilsTraits.hpp	/^  size_t cols = 0;$/;"	m	struct:etr::MatrixParameter	typeref:typename:size_t	access:public
cols	UtilsTraits.hpp	/^  size_t cols;$/;"	m	struct:etr::BaseCalc	typeref:typename:size_t	access:public
convert	UtilsTraits.hpp	/^constexpr doubleWrapper<BoolTrait> convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<T,bool> doubleWrapper<BoolTrait>	signature:(const T & obj)
convert	UtilsTraits.hpp	/^constexpr doubleWrapper<DoubleTrait> convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<T,double> doubleWrapper<DoubleTrait>	signature:(const T & obj)
convert	UtilsTraits.hpp	/^constexpr doubleWrapper<IntTrait> convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<T,int> doubleWrapper<IntTrait>	signature:(const T & obj)
convert	UtilsTraits.hpp	/^template <typename T> constexpr T convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:T	signature:(const T & obj)
convertIndentation	UtilsTraits.hpp	/^inline std::string convertIndentation(size_t idx) {$/;"	f	namespace:etr	typeref:typename:std::string	signature:(size_t idx)
convertSize	helper.hpp	/^template <typename T> inline size_t convertSize(const T &inp) {$/;"	f	namespace:etr	typeref:typename:size_t	signature:(const T & inp)
convertSubset	subsetting.hpp	/^Subset<R> convertSubset(const Vec<T, R> &&obj) {$/;"	f	namespace:etr	typeref:typename:Subset<R>	signature:(const Vec<T,R> && obj)
convertSubset	subsetting.hpp	/^Subset<R> convertSubset(const Vec<T, R> &obj) {$/;"	f	namespace:etr	typeref:typename:Subset<R>	signature:(const Vec<T,R> & obj)
convertSubset	subsetting.hpp	/^template <typename T, typename R> Subset<R> convertSubset(Vec<T, R> &obj) {$/;"	f	namespace:etr	typeref:typename:Subset<R>	signature:(Vec<T,R> & obj)
cosinus	unaryCalculations.hpp	/^auto cosinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
cosinus	unaryCalculations.hpp	/^auto cosinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Cosinus,CosinusTrait>,UnaryTrait>	signature:(const T & obj)
cosinush	unaryCalculations.hpp	/^auto cosinush(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
cosinush	unaryCalculations.hpp	/^auto cosinush(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,CosinusH,CosinusHTrait>,UnaryTrait>	signature:(const T & obj)
cpp2R	helper.hpp	/^inline SEXP cpp2R() { return R_NilValue; }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:()
cpp2R	helper.hpp	/^inline SEXP cpp2R(bool res) { return Rf_ScalarLogical(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(bool res)
cpp2R	helper.hpp	/^inline SEXP cpp2R(const Vec<L, R, Trait> &res) {$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(const Vec<L,R,Trait> & res)
cpp2R	helper.hpp	/^inline SEXP cpp2R(const char *res) { return Rf_mkString(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(const char * res)
cpp2R	helper.hpp	/^inline SEXP cpp2R(double res) { return Rf_ScalarReal(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(double res)
cpp2R	helper.hpp	/^inline SEXP cpp2R(int res) { return Rf_ScalarInteger(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(int res)
cpp2R	helper.hpp	/^inline SEXP cpp2R(std::string &res) { return Rf_mkString(res.data()); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(std::string & res)
cpp2R	helper.hpp	/^template <typename L, typename R> inline SEXP cpp2R(const Vec<L, R> &&res) {$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(const Vec<L,R> && res)
d	BufferVector.hpp	/^  R d;$/;"	m	struct:etr::Vec	typeref:typename:R	access:public
d	UtilsTraits.hpp	/^  BaseType d;$/;"	m	struct:etr::doubleWrapper	typeref:typename:BaseType	access:public
d2b	UtilsTraits.hpp	/^inline bool d2b(double inp) { return static_cast<bool>(inp); }$/;"	f	namespace:etr	typeref:typename:bool	signature:(double inp)
d2i	UtilsTraits.hpp	/^inline int d2i(double inp) { return static_cast<int>(inp); }$/;"	f	namespace:etr	typeref:typename:int	signature:(double inp)
data	UtilsTraits.hpp	/^  T *data() const { return p; }$/;"	f	struct:etr::BaseStore	typeref:typename:T *	access:public	signature:() const
data	UtilsTraits.hpp	/^  T *data() const { return p; }$/;"	f	struct:etr::Borrow	typeref:typename:T *	access:public	signature:() const
data	UtilsTraits.hpp	/^  T *data() const { return p; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:T *	access:public	signature:() const
defineMatrix	UtilsTraits.hpp	/^void defineMatrix(const L &l, const R &r, MatrixParameter &mp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(const L & l,const R & r,MatrixParameter & mp)
demangle	UtilsTraits.hpp	/^inline std::string demangle(const char *mangledName) {$/;"	f	namespace:etr	typeref:typename:std::string	signature:(const char * mangledName)
dgamma_etr	distri.hpp	/^inline Vec<BaseType> dgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate,const Vec<BaseType> & lg)
dim	helper.hpp	/^inline Vec<BaseType> dim(const Vec<BaseType> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & inp)
dlnorm_etr	distri.hpp	/^inline Vec<BaseType> dlnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lg)
dnorm_etr	distri.hpp	/^inline Vec<BaseType> dnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lg)
doubleWrapper	UtilsTraits.hpp	/^template <typename Trait = DoubleTrait> struct doubleWrapper {$/;"	s	namespace:etr
dunif_etr	distri.hpp	/^inline Vec<BaseType> dunif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lg)
end	BufferVector.hpp	/^  auto end() const {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:() const
end	UtilsTraits.hpp	/^  auto end() const { return It<T>{p + sz}; }$/;"	f	struct:etr::BaseStore	typeref:typename:auto	access:public	signature:() const
end	UtilsTraits.hpp	/^  auto end() const { return It<T>{p + sz}; }$/;"	f	struct:etr::Borrow	typeref:typename:auto	access:public	signature:() const
end	UtilsTraits.hpp	/^  auto end() const { return It<T>{p + sz}; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:auto	access:public	signature:() const
etr	BufferVector.hpp	/^namespace etr {$/;"	n
etr	Derivs.hpp	/^namespace etr {$/;"	n
etr	UtilsTraits.hpp	/^namespace etr {$/;"	n
etr	binaryCalculations.hpp	/^namespace etr {$/;"	n
etr	distri.hpp	/^namespace etr {$/;"	n
etr	helper.hpp	/^namespace etr {$/;"	n
etr	interpolation.hpp	/^namespace etr {$/;"	n
etr	subsetting.hpp	/^namespace etr {$/;"	n
etr	unaryCalculations.hpp	/^namespace etr {$/;"	n
etr::ACosinus	UtilsTraits.hpp	/^inline double ACosinus(double obj) { return acos(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::ACosinusTrait	UtilsTraits.hpp	/^struct ACosinusTrait {};$/;"	s	namespace:etr
etr::ASinus	UtilsTraits.hpp	/^inline double ASinus(double obj) { return asin(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::ASinusTrait	UtilsTraits.hpp	/^struct ASinusTrait {};$/;"	s	namespace:etr
etr::ATangens	UtilsTraits.hpp	/^inline double ATangens(double obj) { return atan(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::ATangensTrait	UtilsTraits.hpp	/^struct ATangensTrait {};$/;"	s	namespace:etr
etr::Addition	UtilsTraits.hpp	/^inline double Addition(double l, double r) { return l + r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
etr::AllVars	Derivs.hpp	/^template <int NBuffer_, int NBorrow_, int NBorrowSEXP_> struct AllVars {$/;"	s	namespace:etr
etr::AllVars::AllVars	Derivs.hpp	/^  AllVars(size_t IndepVarIdx_) : IndepVarIdx(IndepVarIdx_) {}$/;"	f	struct:etr::AllVars	access:public	signature:(size_t IndepVarIdx_)
etr::AllVars::Derivs	Derivs.hpp	/^  std::array<Buffer<BaseType>, NBuffer + NBorrow + NBorrowSEXP> Derivs;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Buffer<BaseType>,NBuffer+NBorrow+NBorrowSEXP>	access:public
etr::AllVars::IndepVarIdx	Derivs.hpp	/^  size_t IndepVarIdx = 0;$/;"	m	struct:etr::AllVars	typeref:typename:size_t	access:public
etr::AllVars::NBorrow	Derivs.hpp	/^  static constexpr int NBorrow = NBorrow_;$/;"	m	struct:etr::AllVars	typeref:typename:int	access:public
etr::AllVars::NBorrowSEXP	Derivs.hpp	/^  static constexpr int NBorrowSEXP = NBorrowSEXP_;$/;"	m	struct:etr::AllVars	typeref:typename:int	access:public
etr::AllVars::NBuffer	Derivs.hpp	/^  static constexpr int NBuffer = NBuffer_;$/;"	m	struct:etr::AllVars	typeref:typename:int	access:public
etr::AllVars::VarSizes	Derivs.hpp	/^  std::array<size_t, NBuffer + NBorrow + NBorrowSEXP> VarSizes;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<size_t,NBuffer+NBorrow+NBorrowSEXP>	access:public
etr::AllVars::im	Derivs.hpp	/^  bool im(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:bool	access:public	signature:(size_t Idx)
etr::AllVars::initBorrow	Derivs.hpp	/^  template <typename... Args> void initBorrow(Args &&...args) {$/;"	f	struct:etr::AllVars	typeref:typename:void	access:public	signature:(Args &&...args)
etr::AllVars::initBorrowSEXP	Derivs.hpp	/^  template <typename... Args> void initBorrowSEXP(Args &&...args) {$/;"	f	struct:etr::AllVars	typeref:typename:void	access:public	signature:(Args &&...args)
etr::AllVars::initBuffer	Derivs.hpp	/^  template <typename... Args> void initBuffer(Args &&...args) {$/;"	f	struct:etr::AllVars	typeref:typename:void	access:public	signature:(Args &&...args)
etr::AllVars::nc	Derivs.hpp	/^  std::size_t nc(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:std::size_t	access:public	signature:(size_t Idx)
etr::AllVars::nr	Derivs.hpp	/^  std::size_t nr(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:std::size_t	access:public	signature:(size_t Idx)
etr::AllVars::size	Derivs.hpp	/^  std::size_t size(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:std::size_t	access:public	signature:(size_t Idx)
etr::AllVars::varBorrow	Derivs.hpp	/^  std::array<Vec<BaseType, Borrow<BaseType>> *, NBorrow> varBorrow;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Vec<BaseType,Borrow<BaseType>> *,NBorrow>	access:public
etr::AllVars::varBorrowSEXP	Derivs.hpp	/^  std::array<Vec<BaseType, BorrowSEXP<BaseType>> *, NBorrowSEXP> varBorrowSEXP;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Vec<BaseType,BorrowSEXP<BaseType>> *,NBorrowSEXP>	access:public
etr::AllVars::varBuffer	Derivs.hpp	/^  std::array<Vec<BaseType, Buffer<BaseType>> *, NBuffer> varBuffer;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Vec<BaseType,Buffer<BaseType>> *,NBuffer>	access:public
etr::BaseCalc	UtilsTraits.hpp	/^struct BaseCalc { \/\/ issue: is this used?$/;"	s	namespace:etr
etr::BaseCalc::cols	UtilsTraits.hpp	/^  size_t cols;$/;"	m	struct:etr::BaseCalc	typeref:typename:size_t	access:public
etr::BaseCalc::im	UtilsTraits.hpp	/^  bool im() const { return this->ismatrix; }$/;"	f	struct:etr::BaseCalc	typeref:typename:bool	access:public	signature:() const
etr::BaseCalc::ismatrix	UtilsTraits.hpp	/^  bool ismatrix;$/;"	m	struct:etr::BaseCalc	typeref:typename:bool	access:public
etr::BaseCalc::nc	UtilsTraits.hpp	/^  size_t nc() const { return cols; }$/;"	f	struct:etr::BaseCalc	typeref:typename:size_t	access:public	signature:() const
etr::BaseCalc::nr	UtilsTraits.hpp	/^  size_t nr() const { return rows; }$/;"	f	struct:etr::BaseCalc	typeref:typename:size_t	access:public	signature:() const
etr::BaseCalc::rows	UtilsTraits.hpp	/^  size_t rows;$/;"	m	struct:etr::BaseCalc	typeref:typename:size_t	access:public
etr::BaseCalc::set_matrix	UtilsTraits.hpp	/^  void set_matrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BaseCalc	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::BaseStore	UtilsTraits.hpp	/^template <typename T, typename BaseTrait> struct BaseStore {$/;"	s	namespace:etr
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore() {$/;"	f	struct:etr::BaseStore	access:public	signature:()
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(BaseStore<T> &&other) noexcept$/;"	f	struct:etr::BaseStore	access:public	signature:(BaseStore<T> && other)
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(SEXP s) {$/;"	f	struct:etr::BaseStore	access:public	signature:(SEXP s)
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(const BaseStore<T> &other)$/;"	f	struct:etr::BaseStore	access:public	signature:(const BaseStore<T> & other)
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(int sz_)$/;"	f	struct:etr::BaseStore	access:public	signature:(int sz_)
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(size_t r, size_t c) = delete;$/;"	p	struct:etr::BaseStore	access:public	signature:(size_t r,size_t c)
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::BaseStore	access:public	signature:(size_t r,size_t c,const double value)
etr::BaseStore::BaseStore	UtilsTraits.hpp	/^  BaseStore(size_t sz_) : sz(sz_), capacity(static_cast<size_t>(sz_ * 1.15)) {$/;"	f	struct:etr::BaseStore	access:public	signature:(size_t sz_)
etr::BaseStore::RetType	UtilsTraits.hpp	/^  using RetType = T;$/;"	t	struct:etr::BaseStore	typeref:typename:T	access:public
etr::BaseStore::Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::BaseStore	typeref:typename:T	access:public
etr::BaseStore::TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = BaseTrait;$/;"	t	struct:etr::BaseStore	typeref:typename:BaseTrait	access:public
etr::BaseStore::allocated	UtilsTraits.hpp	/^  bool allocated = false;$/;"	m	struct:etr::BaseStore	typeref:typename:bool	access:public
etr::BaseStore::back	UtilsTraits.hpp	/^  T &back() { return p[sz]; }$/;"	f	struct:etr::BaseStore	typeref:typename:T &	access:public	signature:()
etr::BaseStore::begin	UtilsTraits.hpp	/^  auto begin() const { return It<T>{p}; }$/;"	f	struct:etr::BaseStore	typeref:typename:auto	access:public	signature:() const
etr::BaseStore::capacity	UtilsTraits.hpp	/^  size_t capacity = 1;$/;"	m	struct:etr::BaseStore	typeref:typename:size_t	access:public
etr::BaseStore::data	UtilsTraits.hpp	/^  T *data() const { return p; }$/;"	f	struct:etr::BaseStore	typeref:typename:T *	access:public	signature:() const
etr::BaseStore::end	UtilsTraits.hpp	/^  auto end() const { return It<T>{p + sz}; }$/;"	f	struct:etr::BaseStore	typeref:typename:auto	access:public	signature:() const
etr::BaseStore::fill	UtilsTraits.hpp	/^  void fill(T val) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(T val)
etr::BaseStore::im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::BaseStore	typeref:typename:bool	access:public	signature:() const
etr::BaseStore::init	UtilsTraits.hpp	/^  void init(size_t size) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(size_t size)
etr::BaseStore::initSEXP	UtilsTraits.hpp	/^  void initSEXP(SEXP s) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(SEXP s)
etr::BaseStore::moveit	UtilsTraits.hpp	/^  template <typename L2> BaseStore &moveit(L2 &other) {$/;"	f	struct:etr::BaseStore	typeref:typename:BaseStore &	access:public	signature:(L2 & other)
etr::BaseStore::mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::BaseStore	typeref:typename:MatrixParameter	access:public
etr::BaseStore::nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::BaseStore	typeref:typename:size_t	access:public	signature:() const
etr::BaseStore::nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::BaseStore	typeref:typename:size_t	access:public	signature:() const
etr::BaseStore::operator =	UtilsTraits.hpp	/^  BaseStore &operator=(const BaseStore<T> &other) { \/\/ deep copy$/;"	f	struct:etr::BaseStore	typeref:typename:BaseStore &	access:public	signature:(const BaseStore<T> & other)
etr::BaseStore::operator []	UtilsTraits.hpp	/^  RetType &operator[](size_t idx) {$/;"	f	struct:etr::BaseStore	typeref:typename:RetType &	access:public	signature:(size_t idx)
etr::BaseStore::operator []	UtilsTraits.hpp	/^  RetType operator[](size_t idx) const {$/;"	f	struct:etr::BaseStore	typeref:typename:RetType	access:public	signature:(size_t idx) const
etr::BaseStore::p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::BaseStore	typeref:typename:T *	access:public
etr::BaseStore::push_back	UtilsTraits.hpp	/^  void push_back(T input) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(T input)
etr::BaseStore::realloc	UtilsTraits.hpp	/^  void realloc(size_t new_size) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(size_t new_size)
etr::BaseStore::resize	UtilsTraits.hpp	/^  void resize(size_t newSize) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(size_t newSize)
etr::BaseStore::setMatrix	UtilsTraits.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
etr::BaseStore::setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::BaseStore::setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
etr::BaseStore::size	UtilsTraits.hpp	/^  size_t size() const { return sz; }$/;"	f	struct:etr::BaseStore	typeref:typename:size_t	access:public	signature:() const
etr::BaseStore::sz	UtilsTraits.hpp	/^  size_t sz = 1;$/;"	m	struct:etr::BaseStore	typeref:typename:size_t	access:public
etr::BaseStore::~BaseStore	UtilsTraits.hpp	/^  ~BaseStore() {$/;"	f	struct:etr::BaseStore	access:public	signature:()
etr::BaseStoreTrait	UtilsTraits.hpp	/^struct BaseStoreTrait {};$/;"	s	namespace:etr
etr::BaseType	UtilsTraits.hpp	/^typedef double BaseType;$/;"	t	namespace:etr	typeref:typename:double
etr::BinaryOperation	binaryCalculations.hpp	/^struct BinaryOperation {$/;"	s	namespace:etr
etr::BinaryOperation::BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const BinaryOperation &&other)$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const BinaryOperation && other)
etr::BinaryOperation::BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const BinaryOperation &other)$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const BinaryOperation & other)
etr::BinaryOperation::BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const BinaryOperation<LType, RType, TraitOther>$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const BinaryOperation<LType,RType,TraitOther> & other)
etr::BinaryOperation::BinaryOperation	binaryCalculations.hpp	/^  BinaryOperation(const L &l_, const R &r_, const MatrixParameter &mp_)$/;"	f	struct:etr::BinaryOperation	access:public	signature:(const L & l_,const R & r_,const MatrixParameter & mp_)
etr::BinaryOperation::CaseTrait	binaryCalculations.hpp	/^  using CaseTrait = BinaryTrait;$/;"	t	struct:etr::BinaryOperation	typeref:typename:BinaryTrait	access:public
etr::BinaryOperation::RetType	binaryCalculations.hpp	/^  using RetType = typename CTrait::RetType;$/;"	t	struct:etr::BinaryOperation	typeref:typename:CTrait::RetType	access:public
etr::BinaryOperation::Type	binaryCalculations.hpp	/^  using Type = DoubleTrait;$/;"	t	struct:etr::BinaryOperation	typeref:typename:DoubleTrait	access:public
etr::BinaryOperation::TypeTrait	binaryCalculations.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::BinaryOperation	typeref:typename:Trait	access:public
etr::BinaryOperation::getSize	binaryCalculations.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:(AV & av)
etr::BinaryOperation::getVal	binaryCalculations.hpp	/^  static RetType getVal($/;"	f	struct:etr::BinaryOperation	typeref:typename:RetType	access:public	signature:(AV & av,size_t VecIdx)
etr::BinaryOperation::im	binaryCalculations.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::BinaryOperation	typeref:typename:bool	access:public	signature:() const
etr::BinaryOperation::l	binaryCalculations.hpp	/^  const L &l;$/;"	m	struct:etr::BinaryOperation	typeref:typename:const L &	access:public
etr::BinaryOperation::mp	binaryCalculations.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::BinaryOperation	typeref:typename:MatrixParameter	access:public
etr::BinaryOperation::nc	binaryCalculations.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:() const
etr::BinaryOperation::nr	binaryCalculations.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:() const
etr::BinaryOperation::operator []	binaryCalculations.hpp	/^  auto operator[](size_t i) const { \/\/ RetType is not suitable as int \/ int -_> should return/;"	f	struct:etr::BinaryOperation	typeref:typename:auto	access:public	signature:(size_t i) const
etr::BinaryOperation::r	binaryCalculations.hpp	/^  const R &r;$/;"	m	struct:etr::BinaryOperation	typeref:typename:const R &	access:public
etr::BinaryOperation::setMatrix	binaryCalculations.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
etr::BinaryOperation::setMatrix	binaryCalculations.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::BinaryOperation::setMatrix	binaryCalculations.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
etr::BinaryOperation::size	binaryCalculations.hpp	/^  size_t size() const {$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:() const
etr::BinaryOperation::typeTraitL	binaryCalculations.hpp	/^  using typeTraitL = L;$/;"	t	struct:etr::BinaryOperation	typeref:typename:L	access:public
etr::BinaryOperation::typeTraitR	binaryCalculations.hpp	/^  using typeTraitR = R;$/;"	t	struct:etr::BinaryOperation	typeref:typename:R	access:public
etr::BinaryTrait	UtilsTraits.hpp	/^struct BinaryTrait {$/;"	s	namespace:etr
etr::BinaryTrait::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::BinaryTrait	typeref:typename:BaseType	access:public
etr::BinaryType	Derivs.hpp	/^struct BinaryType {$/;"	s	namespace:etr
etr::BinaryType::Op	Derivs.hpp	/^  using Op = OpTrait;$/;"	t	struct:etr::BinaryType	typeref:typename:OpTrait	access:public
etr::BinaryType::TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::BinaryType	typeref:typename:Trait	access:public
etr::BinaryType::getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t idx) {$/;"	f	struct:etr::BinaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
etr::BinaryType::getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::BinaryType	typeref:typename:size_t	access:public	signature:(AV & av)
etr::BinaryType::getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t idx) {$/;"	f	struct:etr::BinaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
etr::BinaryType::typeTraitLDeriv	Derivs.hpp	/^  using typeTraitLDeriv = LDeriv;$/;"	t	struct:etr::BinaryType	typeref:typename:LDeriv	access:public
etr::BinaryType::typeTraitRDeriv	Derivs.hpp	/^  using typeTraitRDeriv = RDeriv;$/;"	t	struct:etr::BinaryType	typeref:typename:RDeriv	access:public
etr::BoolConstant	UtilsTraits.hpp	/^template <bool B> using BoolConstant = std::integral_constant<bool, B>;$/;"	t	namespace:etr	typeref:typename:std::integral_constant<bool,B>
etr::BoolTrait	UtilsTraits.hpp	/^struct BoolTrait {};$/;"	s	namespace:etr
etr::Borrow	UtilsTraits.hpp	/^template <typename T, typename BorrowTrait> struct Borrow {$/;"	s	namespace:etr
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(){};$/;"	f	struct:etr::Borrow	access:public	signature:()
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(Borrow<T> &&other) noexcept$/;"	f	struct:etr::Borrow	access:public	signature:(Borrow<T> && other)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(SEXP s) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(SEXP s)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(T *p, size_t sz) {$/;"	f	struct:etr::Borrow	access:public	signature:(T * p,size_t sz)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(const Borrow<T> &other)$/;"	f	struct:etr::Borrow	access:public	signature:(const Borrow<T> & other)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(int i) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(int i)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(size_t i){};$/;"	f	struct:etr::Borrow	access:public	signature:(size_t i)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(size_t r, size_t c) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(size_t r,size_t c)
etr::Borrow::Borrow	UtilsTraits.hpp	/^  Borrow(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::Borrow	access:public	signature:(size_t r,size_t c,const double value)
etr::Borrow::CaseTrait	UtilsTraits.hpp	/^  using CaseTrait = BorrowTrait;$/;"	t	struct:etr::Borrow	typeref:typename:BorrowTrait	access:public
etr::Borrow::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::Borrow	typeref:typename:BaseType	access:public
etr::Borrow::Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::Borrow	typeref:typename:T	access:public
etr::Borrow::TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = BorrowTrait;$/;"	t	struct:etr::Borrow	typeref:typename:BorrowTrait	access:public
etr::Borrow::allocated	UtilsTraits.hpp	/^  bool allocated = false;$/;"	m	struct:etr::Borrow	typeref:typename:bool	access:public
etr::Borrow::back	UtilsTraits.hpp	/^  T &back() { return p[sz]; }$/;"	f	struct:etr::Borrow	typeref:typename:T &	access:public	signature:()
etr::Borrow::begin	UtilsTraits.hpp	/^  auto begin() const { return It<T>{p}; }$/;"	f	struct:etr::Borrow	typeref:typename:auto	access:public	signature:() const
etr::Borrow::capacity	UtilsTraits.hpp	/^  size_t capacity = 1;$/;"	m	struct:etr::Borrow	typeref:typename:size_t	access:public
etr::Borrow::data	UtilsTraits.hpp	/^  T *data() const { return p; }$/;"	f	struct:etr::Borrow	typeref:typename:T *	access:public	signature:() const
etr::Borrow::end	UtilsTraits.hpp	/^  auto end() const { return It<T>{p + sz}; }$/;"	f	struct:etr::Borrow	typeref:typename:auto	access:public	signature:() const
etr::Borrow::fill	UtilsTraits.hpp	/^  void fill(T val) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(T val)
etr::Borrow::im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::Borrow	typeref:typename:bool	access:public	signature:() const
etr::Borrow::init	UtilsTraits.hpp	/^  void init(T *p, size_t sz) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(T * p,size_t sz)
etr::Borrow::init	UtilsTraits.hpp	/^  void init(size_t size) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t size)
etr::Borrow::moveit	UtilsTraits.hpp	/^  template <typename L2> Borrow &moveit(L2 &other) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:Borrow &	access:public	signature:(L2 & other)
etr::Borrow::mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::Borrow	typeref:typename:MatrixParameter	access:public
etr::Borrow::nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::Borrow	typeref:typename:size_t	access:public	signature:() const
etr::Borrow::nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::Borrow	typeref:typename:size_t	access:public	signature:() const
etr::Borrow::operator =	UtilsTraits.hpp	/^  Borrow &operator=(const Borrow<T> &other) {$/;"	f	struct:etr::Borrow	typeref:typename:Borrow &	access:public	signature:(const Borrow<T> & other)
etr::Borrow::operator []	UtilsTraits.hpp	/^  RetType &operator[](size_t idx) {$/;"	f	struct:etr::Borrow	typeref:typename:RetType &	access:public	signature:(size_t idx)
etr::Borrow::operator []	UtilsTraits.hpp	/^  RetType operator[](size_t idx) const {$/;"	f	struct:etr::Borrow	typeref:typename:RetType	access:public	signature:(size_t idx) const
etr::Borrow::p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::Borrow	typeref:typename:T *	access:public
etr::Borrow::push_back	UtilsTraits.hpp	/^  void push_back(T input) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:void	access:public	signature:(T input)
etr::Borrow::realloc	UtilsTraits.hpp	/^  void realloc(int new_size) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:void	access:public	signature:(int new_size)
etr::Borrow::resize	UtilsTraits.hpp	/^  void resize(size_t newSize) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t newSize)
etr::Borrow::set	UtilsTraits.hpp	/^  void set(size_t idx, T val) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t idx,T val)
etr::Borrow::setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::Borrow::setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
etr::Borrow::setPtr	UtilsTraits.hpp	/^  void setPtr(const T *pOther) { this->p = pOther; }$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(const T * pOther)
etr::Borrow::setSize	UtilsTraits.hpp	/^  void setSize(size_t sz_) { this->sz = sz_; }$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t sz_)
etr::Borrow::size	UtilsTraits.hpp	/^  size_t size() const { return sz; }$/;"	f	struct:etr::Borrow	typeref:typename:size_t	access:public	signature:() const
etr::Borrow::sz	UtilsTraits.hpp	/^  size_t sz = 1;$/;"	m	struct:etr::Borrow	typeref:typename:size_t	access:public
etr::Borrow::~Borrow	UtilsTraits.hpp	/^  ~Borrow() {}$/;"	f	struct:etr::Borrow	access:public	signature:()
etr::BorrowSEXP	UtilsTraits.hpp	/^template <typename T, typename BorrowSEXPSEXPTrait> struct BorrowSEXP {$/;"	s	namespace:etr
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP() {}$/;"	f	struct:etr::BorrowSEXP	access:public	signature:()
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(SEXP inp) {$/;"	f	struct:etr::BorrowSEXP	access:public	signature:(SEXP inp)
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(const BorrowSEXP<T> &other) {$/;"	f	struct:etr::BorrowSEXP	access:public	signature:(const BorrowSEXP<T> & other)
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(int i) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(int i)
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(size_t i) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(size_t i)
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(size_t r, size_t c) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(size_t r,size_t c)
etr::BorrowSEXP::BorrowSEXP	UtilsTraits.hpp	/^  BorrowSEXP(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::BorrowSEXP	access:public	signature:(size_t r,size_t c,const double value)
etr::BorrowSEXP::CaseTrait	UtilsTraits.hpp	/^  using CaseTrait = BorrowSEXPSEXPTrait;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXPSEXPTrait	access:public
etr::BorrowSEXP::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:BaseType	access:public
etr::BorrowSEXP::Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:T	access:public
etr::BorrowSEXP::TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = BorrowSEXPSEXPTrait;$/;"	t	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXPSEXPTrait	access:public
etr::BorrowSEXP::allocated	UtilsTraits.hpp	/^  bool allocated = false;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:bool	access:public
etr::BorrowSEXP::back	UtilsTraits.hpp	/^  T &back() { return p[sz]; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:T &	access:public	signature:()
etr::BorrowSEXP::begin	UtilsTraits.hpp	/^  auto begin() const { return It<T>{p}; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:auto	access:public	signature:() const
etr::BorrowSEXP::capacity	UtilsTraits.hpp	/^  size_t capacity = 0;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public
etr::BorrowSEXP::data	UtilsTraits.hpp	/^  T *data() const { return p; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:T *	access:public	signature:() const
etr::BorrowSEXP::end	UtilsTraits.hpp	/^  auto end() const { return It<T>{p + sz}; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:auto	access:public	signature:() const
etr::BorrowSEXP::fill	UtilsTraits.hpp	/^  void fill(T val) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(T val)
etr::BorrowSEXP::im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:bool	access:public	signature:() const
etr::BorrowSEXP::init	UtilsTraits.hpp	/^  void init(size_t size) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(size_t size)
etr::BorrowSEXP::moveit	UtilsTraits.hpp	/^  template <typename L2> BorrowSEXP &moveit(L2 &other) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXP &	access:public	signature:(L2 & other)
etr::BorrowSEXP::mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:MatrixParameter	access:public
etr::BorrowSEXP::nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public	signature:() const
etr::BorrowSEXP::nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public	signature:() const
etr::BorrowSEXP::operator =	UtilsTraits.hpp	/^  BorrowSEXP &operator=(SEXP inp) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXP &	access:public	signature:(SEXP inp)
etr::BorrowSEXP::operator =	UtilsTraits.hpp	/^  BorrowSEXP &operator=(const BorrowSEXP<T> &other) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXP &	access:public	signature:(const BorrowSEXP<T> & other)
etr::BorrowSEXP::operator []	UtilsTraits.hpp	/^  RetType &operator[](size_t pos) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:RetType &	access:public	signature:(size_t pos)
etr::BorrowSEXP::operator []	UtilsTraits.hpp	/^  RetType operator[](size_t pos) const {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:RetType	access:public	signature:(size_t pos) const
etr::BorrowSEXP::p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:T *	access:public
etr::BorrowSEXP::push_back	UtilsTraits.hpp	/^  void push_back(T input) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(T input)
etr::BorrowSEXP::realloc	UtilsTraits.hpp	/^  void realloc(int new_size) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(int new_size)
etr::BorrowSEXP::resize	UtilsTraits.hpp	/^  void resize(size_t newSize) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(size_t newSize)
etr::BorrowSEXP::setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::BorrowSEXP::size	UtilsTraits.hpp	/^  size_t size() const { return sz; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public	signature:() const
etr::BorrowSEXP::sz	UtilsTraits.hpp	/^  size_t sz = 0;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public
etr::BorrowSEXP::todelete	UtilsTraits.hpp	/^  bool todelete = false;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:bool	access:public
etr::BorrowSEXP::~BorrowSEXP	UtilsTraits.hpp	/^  ~BorrowSEXP() {$/;"	f	struct:etr::BorrowSEXP	access:public	signature:()
etr::BorrowSEXPTrait	UtilsTraits.hpp	/^struct BorrowSEXPTrait {};$/;"	s	namespace:etr
etr::BorrowTrait	UtilsTraits.hpp	/^struct BorrowTrait {};$/;"	s	namespace:etr
etr::Buffer	BufferVector.hpp	/^struct Buffer : public BaseStore<T> {$/;"	s	namespace:etr	inherits:BaseStore<T>
etr::Buffer::CaseTrait	BufferVector.hpp	/^  using CaseTrait = CTrait;$/;"	t	struct:etr::Buffer	typeref:typename:CTrait	access:public
etr::Buffer::RetType	BufferVector.hpp	/^  using RetType = T; \/\/ BaseType;$/;"	t	struct:etr::Buffer	typeref:typename:T	access:public
etr::Buffer::TypeTrait	BufferVector.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::Buffer	typeref:typename:Trait	access:public
etr::BufferTrait	UtilsTraits.hpp	/^struct BufferTrait {};$/;"	s	namespace:etr
etr::CommonType	UtilsTraits.hpp	/^typename std::common_type<T1, T2>::type CommonType(T1 arg1, T2 arg2) {$/;"	f	namespace:etr	typeref:typename:std::common_type<T1,T2>::type	signature:(T1 arg1,T2 arg2)
etr::ComparisonTrait	UtilsTraits.hpp	/^struct ComparisonTrait {$/;"	s	namespace:etr
etr::ComparisonTrait::RetType	UtilsTraits.hpp	/^  using RetType = bool;$/;"	t	struct:etr::ComparisonTrait	typeref:typename:bool	access:public
etr::Cosinus	UtilsTraits.hpp	/^inline double Cosinus(double obj) { return cos(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::CosinusH	UtilsTraits.hpp	/^inline double CosinusH(double obj) { return cosh(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::CosinusHTrait	UtilsTraits.hpp	/^struct CosinusHTrait {};$/;"	s	namespace:etr
etr::CosinusTrait	UtilsTraits.hpp	/^struct CosinusTrait {};$/;"	s	namespace:etr
etr::Divide	UtilsTraits.hpp	/^inline double Divide(double l, double r) { return l \/ r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
etr::DivideTrait	UtilsTraits.hpp	/^struct DivideTrait {$/;"	s	namespace:etr
etr::DivideTrait::f	UtilsTraits.hpp	/^  static inline auto f(L l, R r) {$/;"	f	struct:etr::DivideTrait	typeref:typename:auto	access:public	signature:(L l,R r)
etr::DoubleTrait	UtilsTraits.hpp	/^struct DoubleTrait {};$/;"	s	namespace:etr
etr::Equal	UtilsTraits.hpp	/^inline double Equal(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
etr::EqualTrait	UtilsTraits.hpp	/^struct EqualTrait {$/;"	s	namespace:etr
etr::EqualTrait::f	UtilsTraits.hpp	/^  f(L a,$/;"	f	struct:etr::EqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
etr::Exp	UtilsTraits.hpp	/^inline double Exp(double obj) { return exp(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::ExpTrait	UtilsTraits.hpp	/^struct ExpTrait {};$/;"	s	namespace:etr
etr::ExtractDType	Derivs.hpp	/^struct ExtractDType<Vec<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractDType::type	Derivs.hpp	/^  using type = R;$/;"	t	struct:etr::ExtractDType	typeref:typename:R	access:public
etr::ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<Buffer<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<Vec<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<const Buffer<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractDataType	UtilsTraits.hpp	/^struct ExtractDataType<const Vec<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractDataType::RetType	UtilsTraits.hpp	/^  using RetType = T const;$/;"	t	struct:etr::ExtractDataType	typeref:typename:T const	access:public
etr::ExtractDataType::RetType	UtilsTraits.hpp	/^  using RetType = T;$/;"	t	struct:etr::ExtractDataType	typeref:typename:T	access:public
etr::ExtractTypeD	Derivs.hpp	/^struct ExtractTypeD<Vec<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractTypeD	Derivs.hpp	/^struct ExtractTypeD<const Vec<T, R, Trait>> {$/;"	s	namespace:etr
etr::ExtractTypeD::type	Derivs.hpp	/^  using type = R const;$/;"	t	struct:etr::ExtractTypeD	typeref:typename:R const	access:public
etr::ExtractTypeD::type	Derivs.hpp	/^  using type = R;$/;"	t	struct:etr::ExtractTypeD	typeref:typename:R	access:public
etr::ExtractTypeTrait	Derivs.hpp	/^struct ExtractTypeTrait<VarPointer<T, Idx, TypeTrait>> {$/;"	s	namespace:etr
etr::ExtractTypeTrait	Derivs.hpp	/^struct ExtractTypeTrait<const VarPointer<T, Idx, TypeTrait> &> {$/;"	s	namespace:etr
etr::ExtractTypeTrait	Derivs.hpp	/^template <typename T> struct ExtractTypeTrait {$/;"	s	namespace:etr
etr::ExtractTypeTrait::type	Derivs.hpp	/^  using type = TypeTrait;$/;"	t	struct:etr::ExtractTypeTrait	typeref:typename:TypeTrait	access:public
etr::ExtractTypeTrait::type	Derivs.hpp	/^  using type = std::false_type;$/;"	t	struct:etr::ExtractTypeTrait	typeref:typename:std::false_type	access:public
etr::ExtractedDType	Derivs.hpp	/^template <typename T> using ExtractedDType = typename ExtractDType<T>::type;$/;"	t	namespace:etr	typeref:typename:ExtractDType<T>::type
etr::ExtractedTypeD	Derivs.hpp	/^template <typename T> using ExtractedTypeD = typename ExtractTypeD<T>::type;$/;"	t	namespace:etr	typeref:typename:ExtractTypeD<T>::type
etr::ExtractedTypeData	UtilsTraits.hpp	/^using ExtractedTypeData = typename ExtractDataType<T>::RetType;$/;"	t	namespace:etr	typeref:typename:ExtractDataType<T>::RetType
etr::ExtractedTypeTrait	Derivs.hpp	/^using ExtractedTypeTrait = typename ExtractTypeTrait<T>::type;$/;"	t	namespace:etr	typeref:typename:ExtractTypeTrait<T>::type
etr::F	UtilsTraits.hpp	/^using F = BoolConstant<false>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<false>
etr::FALSE	UtilsTraits.hpp	/^using FALSE = BoolConstant<false>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<false>
etr::ISNA	helper.hpp	/^bool ISNA(T inp) {$/;"	f	namespace:etr	typeref:typename:bool	signature:(T inp)
etr::Indices	UtilsTraits.hpp	/^struct Indices : public BaseStore<size_t> {$/;"	s	namespace:etr	inherits:BaseStore<size_t>
etr::Indices::RetType	UtilsTraits.hpp	/^  using RetType = size_t;$/;"	t	struct:etr::Indices	typeref:typename:size_t	access:public
etr::IntTrait	UtilsTraits.hpp	/^struct IntTrait {};$/;"	s	namespace:etr
etr::It	UtilsTraits.hpp	/^template <typename T> struct It {$/;"	s	namespace:etr
etr::It::operator !=	UtilsTraits.hpp	/^  bool operator!=(const It &rhs) { return p != rhs.p; }$/;"	f	struct:etr::It	typeref:typename:bool	access:public	signature:(const It & rhs)
etr::It::operator *	UtilsTraits.hpp	/^  T &operator*() { return *p; }$/;"	f	struct:etr::It	typeref:typename:T &	access:public	signature:()
etr::It::operator ++	UtilsTraits.hpp	/^  void operator++() { ++p; }$/;"	f	struct:etr::It	typeref:typename:void	access:public	signature:()
etr::It::p	UtilsTraits.hpp	/^  T *p;$/;"	m	struct:etr::It	typeref:typename:T *	access:public
etr::Larger	UtilsTraits.hpp	/^inline double Larger(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
etr::LargerEqual	UtilsTraits.hpp	/^inline double LargerEqual(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
etr::LargerEqualTrait	UtilsTraits.hpp	/^struct LargerEqualTrait {$/;"	s	namespace:etr
etr::LargerEqualTrait::f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::LargerEqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
etr::LargerTrait	UtilsTraits.hpp	/^struct LargerTrait {$/;"	s	namespace:etr
etr::LargerTrait::f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::LargerTrait	typeref:typename:bool	access:public	signature:(L a,R b)
etr::Log	UtilsTraits.hpp	/^inline double Log(double obj) { return log(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::LogTrait	UtilsTraits.hpp	/^struct LogTrait {};$/;"	s	namespace:etr
etr::LoopVariadicT	Derivs.hpp	/^template <class F, class... Args> inline F LoopVariadicT(F f, Args &&...args) {$/;"	f	namespace:etr	typeref:typename:F	signature:(F f,Args &&...args)
etr::MatrixParameter	UtilsTraits.hpp	/^struct MatrixParameter {$/;"	s	namespace:etr
etr::MatrixParameter::MatrixParameter	UtilsTraits.hpp	/^  MatrixParameter() {}$/;"	f	struct:etr::MatrixParameter	access:public	signature:()
etr::MatrixParameter::MatrixParameter	UtilsTraits.hpp	/^  MatrixParameter(const MatrixParameter &other)$/;"	f	struct:etr::MatrixParameter	access:public	signature:(const MatrixParameter & other)
etr::MatrixParameter::MatrixParameter	UtilsTraits.hpp	/^  MatrixParameter(size_t rows_, size_t cols_)$/;"	f	struct:etr::MatrixParameter	access:public	signature:(size_t rows_,size_t cols_)
etr::MatrixParameter::cols	UtilsTraits.hpp	/^  size_t cols = 0;$/;"	m	struct:etr::MatrixParameter	typeref:typename:size_t	access:public
etr::MatrixParameter::im	UtilsTraits.hpp	/^  bool im() const { return this->ismatrix; }$/;"	f	struct:etr::MatrixParameter	typeref:typename:bool	access:public	signature:() const
etr::MatrixParameter::ismatrix	UtilsTraits.hpp	/^  bool ismatrix = false;$/;"	m	struct:etr::MatrixParameter	typeref:typename:bool	access:public
etr::MatrixParameter::nc	UtilsTraits.hpp	/^  size_t nc() const { return cols; }$/;"	f	struct:etr::MatrixParameter	typeref:typename:size_t	access:public	signature:() const
etr::MatrixParameter::nr	UtilsTraits.hpp	/^  size_t nr() const { return rows; }$/;"	f	struct:etr::MatrixParameter	typeref:typename:size_t	access:public	signature:() const
etr::MatrixParameter::rows	UtilsTraits.hpp	/^  size_t rows = 0;$/;"	m	struct:etr::MatrixParameter	typeref:typename:size_t	access:public
etr::MatrixParameter::setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::MatrixParameter	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::MatrixParameter::setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::MatrixParameter	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
etr::Minus	UtilsTraits.hpp	/^inline double Minus(double l, double r) { return l - r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
etr::MinusTrait	UtilsTraits.hpp	/^struct MinusTrait {$/;"	s	namespace:etr
etr::MinusTrait::f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::MinusTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
etr::MinusUnary	UtilsTraits.hpp	/^inline double MinusUnary(double obj) { return -obj; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::MinusUnaryTrait	UtilsTraits.hpp	/^struct MinusUnaryTrait {};$/;"	s	namespace:etr
etr::NA_REAL	UtilsTraits.hpp	/^const double NA_REAL = std::numeric_limits<double>::quiet_NaN();$/;"	v	namespace:etr	typeref:typename:const double
etr::PlusDeriv	UtilsTraits.hpp	/^inline double PlusDeriv(double lDeriv, double rDeriv) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double lDeriv,double rDeriv)
etr::PlusDerivTrait	UtilsTraits.hpp	/^template <typename L, typename R> struct PlusDerivTrait {$/;"	s	namespace:etr
etr::PlusDerivTrait::RetType	UtilsTraits.hpp	/^  using RetType = decltype(CommonType<L, R>);$/;"	t	struct:etr::PlusDerivTrait	access:public
etr::PlusDerivTrait::f	UtilsTraits.hpp	/^  static inline decltype(CommonType<L, R>()) f(L l, R r) { return l + r; }$/;"	f	struct:etr::PlusDerivTrait	typeref:typename:decltype(CommonType<L,R> ())	access:public	signature:(L l,R r)
etr::PlusTrait	UtilsTraits.hpp	/^struct PlusTrait {$/;"	s	namespace:etr
etr::PlusTrait::f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::PlusTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
etr::Pow	UtilsTraits.hpp	/^inline double Pow(double l, double r) { return std::pow(l, r); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
etr::PowTrait	UtilsTraits.hpp	/^struct PowTrait {$/;"	s	namespace:etr
etr::PowTrait::f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::PowTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
etr::QuarternaryTrait	UtilsTraits.hpp	/^struct QuarternaryTrait {$/;"	s	namespace:etr
etr::QuarternaryTrait::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::QuarternaryTrait	typeref:typename:BaseType	access:public
etr::QuarternyType	Derivs.hpp	/^struct QuarternyType {$/;"	s	namespace:etr
etr::QuarternyType::TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::QuarternyType	typeref:typename:Trait	access:public
etr::QuarternyType::getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t idx) {$/;"	f	struct:etr::QuarternyType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
etr::QuarternyType::getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::QuarternyType	typeref:typename:size_t	access:public	signature:(AV & av)
etr::QuarternyType::getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t idx) {$/;"	f	struct:etr::QuarternyType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
etr::QuarternyType::typeTraitL	Derivs.hpp	/^  using typeTraitL = L;$/;"	t	struct:etr::QuarternyType	typeref:typename:L	access:public
etr::QuarternyType::typeTraitLDeriv	Derivs.hpp	/^  using typeTraitLDeriv = LDeriv;$/;"	t	struct:etr::QuarternyType	typeref:typename:LDeriv	access:public
etr::QuarternyType::typeTraitR	Derivs.hpp	/^  using typeTraitR = R;$/;"	t	struct:etr::QuarternyType	typeref:typename:R	access:public
etr::QuarternyType::typeTraitRDeriv	Derivs.hpp	/^  using typeTraitRDeriv = RDeriv;$/;"	t	struct:etr::QuarternyType	typeref:typename:RDeriv	access:public
etr::R::Type	UtilsTraits.hpp	/^  typename R::Type;$/;"	m	class:etr::R	typeref:meta:typename
etr::R::TypeTrait	UtilsTraits.hpp	/^  typename R::TypeTrait;$/;"	m	class:etr::R	typeref:meta:typename
etr::RBufTrait	UtilsTraits.hpp	/^struct RBufTrait {};$/;"	s	namespace:etr
etr::RVecTrait	UtilsTraits.hpp	/^struct RVecTrait {};$/;"	s	namespace:etr
etr::R_FINITE	helper.hpp	/^bool R_FINITE(T inp) {$/;"	f	namespace:etr	typeref:typename:bool	signature:(T inp)
etr::R_PosInf	UtilsTraits.hpp	/^const double R_PosInf = std::numeric_limits<double>::infinity();$/;"	v	namespace:etr	typeref:typename:const double
etr::Sinus	UtilsTraits.hpp	/^inline double Sinus(double obj) { return sin(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::SinusDerivTrait	UtilsTraits.hpp	/^struct SinusDerivTrait {$/;"	s	namespace:etr
etr::SinusDerivTrait::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::SinusDerivTrait	typeref:typename:BaseType	access:public
etr::SinusH	UtilsTraits.hpp	/^inline double SinusH(double obj) { return sinh(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::SinusHTrait	UtilsTraits.hpp	/^struct SinusHTrait {};$/;"	s	namespace:etr
etr::SinusTrait	UtilsTraits.hpp	/^struct SinusTrait {};$/;"	s	namespace:etr
etr::Smaller	UtilsTraits.hpp	/^inline double Smaller(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
etr::SmallerEqual	UtilsTraits.hpp	/^inline double SmallerEqual(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
etr::SmallerEqualTrait	UtilsTraits.hpp	/^struct SmallerEqualTrait {$/;"	s	namespace:etr
etr::SmallerEqualTrait::f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::SmallerEqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
etr::SmallerTrait	UtilsTraits.hpp	/^struct SmallerTrait {$/;"	s	namespace:etr
etr::SmallerTrait::f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::SmallerTrait	typeref:typename:bool	access:public	signature:(L a,R b)
etr::SquareRoot	UtilsTraits.hpp	/^inline double SquareRoot(double obj) { return sqrt(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::SquareRootTrait	UtilsTraits.hpp	/^struct SquareRootTrait {};$/;"	s	namespace:etr
etr::Subset	UtilsTraits.hpp	/^template <typename T, typename SubsetTrait> struct Subset {$/;"	s	namespace:etr
etr::Subset::CaseTrait	UtilsTraits.hpp	/^  using CaseTrait = SubsetTrait;$/;"	t	struct:etr::Subset	typeref:typename:SubsetTrait	access:public
etr::Subset::CurrentBaseType	UtilsTraits.hpp	/^  using CurrentBaseType = std::remove_reference<decltype(*p)>::type::Type;$/;"	t	struct:etr::Subset	access:public
etr::Subset::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::Subset	typeref:typename:BaseType	access:public
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset() = delete;$/;"	p	struct:etr::Subset	access:public	signature:()
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(SEXP) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(SEXP)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(const Subset &&other) {$/;"	f	struct:etr::Subset	access:public	signature:(const Subset && other)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(const Subset &other) {$/;"	f	struct:etr::Subset	access:public	signature:(const Subset & other)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(const Vec<T2, R2, TraitOther> &other) {$/;"	f	struct:etr::Subset	access:public	signature:(const Vec<T2,R2,TraitOther> & other)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(int i) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(int i)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(size_t i) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(size_t i)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(size_t r, size_t c) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(size_t r,size_t c)
etr::Subset::Subset	UtilsTraits.hpp	/^  Subset(size_t r, size_t c, const double value) = delete;$/;"	p	struct:etr::Subset	access:public	signature:(size_t r,size_t c,const double value)
etr::Subset::Subset	UtilsTraits.hpp	/^  template <typename T2, typename R2> Subset(Vec<T2, R2> &other) {$/;"	f	struct:etr::Subset	access:public	signature:(Vec<T2,R2> & other)
etr::Subset::Type	UtilsTraits.hpp	/^  using Type = T;$/;"	t	struct:etr::Subset	typeref:typename:T	access:public
etr::Subset::TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = SubsetTrait;$/;"	t	struct:etr::Subset	typeref:typename:SubsetTrait	access:public
etr::Subset::im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::Subset	typeref:typename:bool	access:public	signature:() const
etr::Subset::ind	UtilsTraits.hpp	/^  Indices ind;$/;"	m	struct:etr::Subset	typeref:typename:Indices	access:public
etr::Subset::mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::Subset	typeref:typename:MatrixParameter	access:public
etr::Subset::nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::Subset	typeref:typename:size_t	access:public	signature:() const
etr::Subset::nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::Subset	typeref:typename:size_t	access:public	signature:() const
etr::Subset::operator []	UtilsTraits.hpp	/^  CurrentBaseType &operator[](size_t pos) {$/;"	f	struct:etr::Subset	typeref:typename:CurrentBaseType &	access:public	signature:(size_t pos)
etr::Subset::operator []	UtilsTraits.hpp	/^  CurrentBaseType operator[](size_t pos) const {$/;"	f	struct:etr::Subset	typeref:typename:CurrentBaseType	access:public	signature:(size_t pos) const
etr::Subset::p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::Subset	typeref:typename:T *	access:public
etr::Subset::realloc	UtilsTraits.hpp	/^  void realloc(size_t newSize) { p->realloc(newSize); }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(size_t newSize)
etr::Subset::resize	UtilsTraits.hpp	/^  void resize(size_t newSize) { p->resize(newSize); }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(size_t newSize)
etr::Subset::resizeInd	UtilsTraits.hpp	/^  void resizeInd(int newSize) { ind.resize(newSize); }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(int newSize)
etr::Subset::setInd	UtilsTraits.hpp	/^  void setInd(int idx, int val) { ind[idx] = val; }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(int idx,int val)
etr::Subset::setMatrix	UtilsTraits.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
etr::Subset::setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::Subset::setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
etr::Subset::setPtr	UtilsTraits.hpp	/^  void setPtr(const T *pOther) { this->p = pOther; }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(const T * pOther)
etr::Subset::size	UtilsTraits.hpp	/^  size_t size() const { return ind.size(); }$/;"	f	struct:etr::Subset	typeref:typename:size_t	access:public	signature:() const
etr::Subset::~Subset	UtilsTraits.hpp	/^  ~Subset() {}$/;"	f	struct:etr::Subset	access:public	signature:()
etr::SubsetTrait	UtilsTraits.hpp	/^struct SubsetTrait {};$/;"	s	namespace:etr
etr::T	UtilsTraits.hpp	/^using T = BoolConstant<true>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<true>
etr::T::CaseTrait	UtilsTraits.hpp	/^  typename T::CaseTrait;$/;"	m	class:etr::T	typeref:meta:typename
etr::TRUE	UtilsTraits.hpp	/^using TRUE = BoolConstant<true>;$/;"	t	namespace:etr	typeref:typename:BoolConstant<true>
etr::Tangens	UtilsTraits.hpp	/^inline double Tangens(double obj) { return tan(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::TangensH	UtilsTraits.hpp	/^inline double TangensH(double obj) { return tanh(obj); }$/;"	f	namespace:etr	typeref:typename:double	signature:(double obj)
etr::TangensHTrait	UtilsTraits.hpp	/^struct TangensHTrait {};$/;"	s	namespace:etr
etr::TangensTrait	UtilsTraits.hpp	/^struct TangensTrait {};$/;"	s	namespace:etr
etr::Times	UtilsTraits.hpp	/^inline double Times(double l, double r) { return l * r; }$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r)
etr::TimesDeriv	UtilsTraits.hpp	/^inline double TimesDeriv(double l, double r, double lDeriv, double rDeriv) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double l,double r,double lDeriv,double rDeriv)
etr::TimesDerivTrait	UtilsTraits.hpp	/^struct TimesDerivTrait {$/;"	s	namespace:etr
etr::TimesDerivTrait::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::TimesDerivTrait	typeref:typename:BaseType	access:public
etr::TimesTrait	UtilsTraits.hpp	/^struct TimesTrait {$/;"	s	namespace:etr
etr::TimesTrait::f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::TimesTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
etr::UnEqual	UtilsTraits.hpp	/^inline double UnEqual(double a, double b) {$/;"	f	namespace:etr	typeref:typename:double	signature:(double a,double b)
etr::UnEqualTrait	UtilsTraits.hpp	/^struct UnEqualTrait {$/;"	s	namespace:etr
etr::UnEqualTrait::f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::UnEqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
etr::UnaryFct	UtilsTraits.hpp	/^typedef double (*UnaryFct)(double);$/;"	t	namespace:etr	typeref:typename:double (*)(double)
etr::UnaryOperation	unaryCalculations.hpp	/^struct UnaryOperation {$/;"	s	namespace:etr
etr::UnaryOperation::CaseTrait	unaryCalculations.hpp	/^  using CaseTrait = CTrait;$/;"	t	struct:etr::UnaryOperation	typeref:typename:CTrait	access:public
etr::UnaryOperation::RetType	unaryCalculations.hpp	/^  using RetType = typename CTrait::RetType;$/;"	t	struct:etr::UnaryOperation	typeref:typename:CTrait::RetType	access:public
etr::UnaryOperation::TypeTrait	unaryCalculations.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::UnaryOperation	typeref:typename:Trait	access:public
etr::UnaryOperation::UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const I &obj_, const MatrixParameter &mp)$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const I & obj_,const MatrixParameter & mp)
etr::UnaryOperation::UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const UnaryOperation &&other) : obj(other.obj), mp(other.mp) {}$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const UnaryOperation && other)
etr::UnaryOperation::UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const UnaryOperation &other) : obj(other.obj), mp(other.mp) {}$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const UnaryOperation & other)
etr::UnaryOperation::UnaryOperation	unaryCalculations.hpp	/^  UnaryOperation(const UnaryOperation<IType, fOther, TraitOther> &other)$/;"	f	struct:etr::UnaryOperation	access:public	signature:(const UnaryOperation<IType,fOther,TraitOther> & other)
etr::UnaryOperation::getSize	unaryCalculations.hpp	/^  template <typename AV> static RetType getSize(AV &av) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:RetType	access:public	signature:(AV & av)
etr::UnaryOperation::getVal	unaryCalculations.hpp	/^  template <typename AV> static RetType getVal(AV &av, size_t VecIdx) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:RetType	access:public	signature:(AV & av,size_t VecIdx)
etr::UnaryOperation::im	unaryCalculations.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::UnaryOperation	typeref:typename:bool	access:public	signature:() const
etr::UnaryOperation::mp	unaryCalculations.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::UnaryOperation	typeref:typename:MatrixParameter	access:public
etr::UnaryOperation::nc	unaryCalculations.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::UnaryOperation	typeref:typename:size_t	access:public	signature:() const
etr::UnaryOperation::nr	unaryCalculations.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::UnaryOperation	typeref:typename:size_t	access:public	signature:() const
etr::UnaryOperation::obj	unaryCalculations.hpp	/^  const I &obj;$/;"	m	struct:etr::UnaryOperation	typeref:typename:const I &	access:public
etr::UnaryOperation::operator []	unaryCalculations.hpp	/^  RetType operator[](size_t i) const {$/;"	f	struct:etr::UnaryOperation	typeref:typename:RetType	access:public	signature:(size_t i) const
etr::UnaryOperation::setMatrix	unaryCalculations.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
etr::UnaryOperation::setMatrix	unaryCalculations.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
etr::UnaryOperation::setMatrix	unaryCalculations.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
etr::UnaryOperation::size	unaryCalculations.hpp	/^  size_t size() const {$/;"	f	struct:etr::UnaryOperation	typeref:typename:size_t	access:public	signature:() const
etr::UnaryOperation::typeTraitObj	unaryCalculations.hpp	/^  using typeTraitObj = I;$/;"	t	struct:etr::UnaryOperation	typeref:typename:I	access:public
etr::UnaryTrait	UtilsTraits.hpp	/^struct UnaryTrait {$/;"	s	namespace:etr
etr::UnaryTrait::RetType	UtilsTraits.hpp	/^  using RetType = BaseType;$/;"	t	struct:etr::UnaryTrait	typeref:typename:BaseType	access:public
etr::UnaryType	Derivs.hpp	/^template <typename Deriv, typename Trait, typename OpTrait> struct UnaryType {$/;"	s	namespace:etr
etr::UnaryType::TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::UnaryType	typeref:typename:Trait	access:public
etr::UnaryType::getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t idx) {$/;"	f	struct:etr::UnaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
etr::UnaryType::getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::UnaryType	typeref:typename:size_t	access:public	signature:(AV & av)
etr::UnaryType::getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t idx) {$/;"	f	struct:etr::UnaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
etr::UnaryType::typeTraitObj	Derivs.hpp	/^  using typeTraitObj = Deriv;$/;"	t	struct:etr::UnaryType	typeref:typename:Deriv	access:public
etr::VarPointer	Derivs.hpp	/^struct VarPointer {$/;"	s	namespace:etr
etr::VarPointer::AllVarsRef	Derivs.hpp	/^  T &AllVarsRef;$/;"	m	struct:etr::VarPointer	typeref:typename:T &	access:public
etr::VarPointer::CaseTrait	Derivs.hpp	/^  using CaseTrait = Trait;$/;"	t	struct:etr::VarPointer	typeref:typename:Trait	access:public
etr::VarPointer::I	Derivs.hpp	/^  static constexpr int I = Idx;$/;"	m	struct:etr::VarPointer	typeref:typename:int	access:public
etr::VarPointer::TypeTrait	Derivs.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::VarPointer	typeref:typename:Trait	access:public
etr::VarPointer::VarPointer	Derivs.hpp	/^  VarPointer(T &AllVars_) : AllVarsRef(AllVars_) {}$/;"	f	struct:etr::VarPointer	access:public	signature:(T & AllVars_)
etr::VarPointer::get	Derivs.hpp	/^  auto get() const {$/;"	f	struct:etr::VarPointer	typeref:typename:auto	access:public	signature:() const
etr::VarPointer::getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VarPointer	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
etr::VarPointer::getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:(AV & av)
etr::VarPointer::getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VarPointer	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
etr::VarPointer::im	Derivs.hpp	/^  bool im() { return AllVarsRef.im(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:bool	access:public	signature:()
etr::VarPointer::nc	Derivs.hpp	/^  size_t nc() { return AllVarsRef.nc(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:()
etr::VarPointer::nr	Derivs.hpp	/^  size_t nr() { return AllVarsRef.nr(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:()
etr::VarPointer::size	Derivs.hpp	/^  size_t size() { return AllVarsRef.size(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:()
etr::VarPointerTrait	Derivs.hpp	/^struct VarPointerTrait {};$/;"	s	namespace:etr
etr::VariableTrait	UtilsTraits.hpp	/^struct VariableTrait {};$/;"	s	namespace:etr
etr::VariableType	Derivs.hpp	/^template <typename T> struct VariableType {$/;"	s	namespace:etr
etr::VariableType::Type	Derivs.hpp	/^  using Type = T;$/;"	t	struct:etr::VariableType	typeref:typename:T	access:public
etr::VariableType::TypeTrait	Derivs.hpp	/^  using TypeTrait = VariableTypeTrait;$/;"	t	struct:etr::VariableType	typeref:typename:VariableTypeTrait	access:public
etr::VariableType::getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VariableType	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
etr::VariableType::getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::VariableType	typeref:typename:size_t	access:public	signature:(AV & av)
etr::VariableType::getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VariableType	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
etr::VariableTypeTrait	Derivs.hpp	/^struct VariableTypeTrait {};$/;"	s	namespace:etr
etr::Vec	BufferVector.hpp	/^template <typename T, typename R, typename Trait> struct Vec {$/;"	s	namespace:etr
etr::Vec::CaseTrait	BufferVector.hpp	/^  using CaseTrait = Trait;$/;"	t	struct:etr::Vec	typeref:typename:Trait	access:public
etr::Vec::DType	BufferVector.hpp	/^  using DType = R;$/;"	t	struct:etr::Vec	typeref:typename:R	access:public
etr::Vec::RetType	BufferVector.hpp	/^  using RetType = std::remove_reference<decltype(d)>::type::RetType;$/;"	t	struct:etr::Vec	access:public
etr::Vec::Type	BufferVector.hpp	/^  using Type = T;$/;"	t	struct:etr::Vec	typeref:typename:T	access:public
etr::Vec::TypeTrait	BufferVector.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::Vec	typeref:typename:Trait	access:public
etr::Vec::Vec	BufferVector.hpp	/^                                                     explicit Vec(size_t sz)$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,BorrowSEXP<BaseType>>	access:public	signature:(size_t sz)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(BaseType *ptr, size_t rows, size_t cols) : d(rows * cols) {$/;"	f	struct:etr::Vec	access:public	signature:(BaseType * ptr,size_t rows,size_t cols)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(BaseType *ptr, size_t size) : d(size) {$/;"	f	struct:etr::Vec	access:public	signature:(BaseType * ptr,size_t size)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(Rboolean b) : d(1) {$/;"	f	struct:etr::Vec	access:public	signature:(Rboolean b)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(Rcpp::NumericMatrix otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(Rcpp::NumericMatrix otherVec)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(Rcpp::NumericVector otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(Rcpp::NumericVector otherVec)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(arma::mat otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(arma::mat otherVec)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(arma::vec otherVec) : d() {$/;"	f	struct:etr::Vec	access:public	signature:(arma::vec otherVec)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(bool b) : d(1) { d[0] = static_cast<BaseType>(b); }$/;"	f	struct:etr::Vec	access:public	signature:(bool b)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(const Vec<T2, R2, Trait2> &other_vec) { \/\/ : d()$/;"	f	struct:etr::Vec	access:public	signature:(const Vec<T2,R2,Trait2> & other_vec)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(const Vec<T2, R2, Trait2>$/;"	f	struct:etr::Vec	access:public	signature:(const Vec<T2,R2,Trait2> && other_vec)
etr::Vec::Vec	BufferVector.hpp	/^  Vec(double sz) : d(1) {$/;"	f	struct:etr::Vec	access:public	signature:(double sz)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec($/;"	f	struct:etr::Vec	access:public	signature:(const BinaryOperation<L2,R2,OperationTrait,DetailTrait> && inp)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec() : d() {}$/;"	f	struct:etr::Vec	access:public	signature:()
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(BinaryOperation<L2, R2, OperationTrait> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(BinaryOperation<L2,R2,OperationTrait> & inp)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(T *ptr, size_t s) : d(ptr, s) {}$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,Borrow<T>>	access:public	signature:(T * ptr,size_t s)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(UnaryOperation<L2, f, OperationTrait> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(UnaryOperation<L2,f,OperationTrait> & inp)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(const BinaryOperation<L2, R2, OperationTrait> &&inp)$/;"	f	struct:etr::Vec	access:public	signature:(const BinaryOperation<L2,R2,OperationTrait> && inp)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(const Borrow<T2> &&borrowed) : d(borrowed) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,Borrow<BaseType>>	access:public	signature:(const Borrow<T2> && borrowed)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(const Borrow<T2> &borrowed) : d(borrowed) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<U,Borrow<T>>	access:public	signature:(const Borrow<T2> & borrowed)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(const Buffer<L2, TraitOther> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Buffer<L2,TraitOther> & inp)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(const UnaryOperation<L2, f, OperationTrait> &&inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const UnaryOperation<L2,f,OperationTrait> && inp)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(const Vec<T2> &other_vec) : d() {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<T2,bool>	access:public	signature:(const Vec<T2> & other_vec)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(int sz) : d(static_cast<size_t>(sz)) {}$/;"	f	struct:etr::Vec	access:public	signature:(int sz)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(size_t rows, size_t cols) : d(rows * cols) {$/;"	f	struct:etr::Vec	access:public	signature:(size_t rows,size_t cols)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(size_t rows, size_t cols, const double value) : d(rows * cols) {$/;"	f	struct:etr::Vec	access:public	signature:(size_t rows,size_t cols,const double value)
etr::Vec::Vec	BufferVector.hpp	/^  explicit Vec(size_t sz) : d(sz) {}$/;"	f	struct:etr::Vec	access:public	signature:(size_t sz)
etr::Vec::Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(Subset<L2> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(Subset<L2> & inp)
etr::Vec::Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(const Buffer<L2> &&inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Buffer<L2> && inp)
etr::Vec::Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(const Buffer<L2> &inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Buffer<L2> & inp)
etr::Vec::Vec	BufferVector.hpp	/^  template <typename L2> explicit Vec(const Subset<L2> &&inp) : d(inp) {$/;"	f	struct:etr::Vec	access:public	signature:(const Subset<L2> && inp)
etr::Vec::Vec	BufferVector.hpp	/^  template <typename T2> Vec(T2 n) = delete;$/;"	p	struct:etr::Vec	access:public	signature:(T2 n)
etr::Vec::back	BufferVector.hpp	/^  T &back() const { return d.p[this->size()]; }$/;"	f	struct:etr::Vec	typeref:typename:T &	access:public	signature:() const
etr::Vec::begin	BufferVector.hpp	/^  auto begin() const {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:() const
etr::Vec::caseTraitD	BufferVector.hpp	/^  using caseTraitD = std::remove_reference<decltype(d)>::type::CaseTrait;$/;"	t	struct:etr::Vec	access:public
etr::Vec::d	BufferVector.hpp	/^  R d;$/;"	m	struct:etr::Vec	typeref:typename:R	access:public
etr::Vec::end	BufferVector.hpp	/^  auto end() const {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:() const
etr::Vec::fill	BufferVector.hpp	/^  void fill(T value) { d.fill(value); }$/;"	f	struct:etr::Vec	typeref:typename:void	access:public	signature:(T value)
etr::Vec::getRetType	BufferVector.hpp	/^  RetType getRetType() const { return RetType{}; }$/;"	f	struct:etr::Vec	typeref:typename:RetType	access:public	signature:() const
etr::Vec::im	BufferVector.hpp	/^  bool im() const { return d.im(); }$/;"	f	struct:etr::Vec	typeref:typename:bool	access:public	signature:() const
etr::Vec::isBinaryOP	BufferVector.hpp	/^  using isBinaryOP = std::is_same<caseTraitD, BinaryTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<caseTraitD,BinaryTrait>	access:public
etr::Vec::isBorrow	BufferVector.hpp	/^  using isBorrow = std::is_same<typeTraitD, BorrowTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,BorrowTrait>	access:public
etr::Vec::isBorrowSEXP	BufferVector.hpp	/^  using isBorrowSEXP = std::is_same<typeTraitD, BorrowSEXPTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,BorrowSEXPTrait>	access:public
etr::Vec::isBuffer	BufferVector.hpp	/^  using isBuffer = std::is_same<typeTraitD, BufferTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,BufferTrait>	access:public
etr::Vec::isSubset	BufferVector.hpp	/^  using isSubset = std::is_same<typeTraitD, SubsetTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,SubsetTrait>	access:public
etr::Vec::isUnaryOP	BufferVector.hpp	/^  using isUnaryOP = std::is_same<caseTraitD, UnaryTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<caseTraitD,UnaryTrait>	access:public
etr::Vec::nc	BufferVector.hpp	/^  size_t nc() const { return d.nc(); }$/;"	f	struct:etr::Vec	typeref:typename:size_t	access:public	signature:() const
etr::Vec::nr	BufferVector.hpp	/^  size_t nr() const { return d.nr(); }$/;"	f	struct:etr::Vec	typeref:typename:size_t	access:public	signature:() const
etr::Vec::operator ()	BufferVector.hpp	/^  auto operator()(const IL &idxL, const IR &idxR) {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:(const IL & idxL,const IR & idxR)
etr::Vec::operator ()	BufferVector.hpp	/^  template <typename I> auto operator()(const I &idx) {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:(const I & idx)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(Rcpp::NumericMatrix &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(Rcpp::NumericMatrix & otherVec)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(Rcpp::NumericVector &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(Rcpp::NumericVector & otherVec)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(SEXP s) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(SEXP s)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(Vec<BaseType> &other) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(Vec<BaseType> & other)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(arma::mat &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(arma::mat & otherVec)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(arma::vec &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(arma::vec & otherVec)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(const T inp) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(const T inp)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(const TD inp) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<TD,bool> Vec &	access:public	signature:(const TD inp)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(const TD inp) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<TD,int> Vec &	access:public	signature:(const TD inp)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(const Vec<T, R, Trait> &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(const Vec<T,R,Trait> & otherVec)
etr::Vec::operator =	BufferVector.hpp	/^  Vec &operator=(const Vec<T2, R2, Trait2> &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(const Vec<T2,R2,Trait2> & otherVec)
etr::Vec::operator Rcpp::NumericMatrix	BufferVector.hpp	/^  operator Rcpp::NumericMatrix() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
etr::Vec::operator Rcpp::NumericVector	BufferVector.hpp	/^  operator Rcpp::NumericVector() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
etr::Vec::operator RetType	BufferVector.hpp	/^  operator RetType() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
etr::Vec::operator []	BufferVector.hpp	/^  RetType &operator[](size_t idx) { return d[idx]; }$/;"	f	struct:etr::Vec	typeref:typename:RetType &	access:public	signature:(size_t idx)
etr::Vec::operator []	BufferVector.hpp	/^  RetType operator[](size_t idx) const { return d[idx]; }$/;"	f	struct:etr::Vec	typeref:typename:RetType	access:public	signature:(size_t idx) const
etr::Vec::operator arma::mat	BufferVector.hpp	/^  operator arma::mat() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
etr::Vec::operator arma::vec	BufferVector.hpp	/^  operator arma::vec() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
etr::Vec::resize	BufferVector.hpp	/^  void resize(size_t newSize) { d.resize(newSize); }$/;"	f	struct:etr::Vec	typeref:typename:void	access:public	signature:(size_t newSize)
etr::Vec::size	BufferVector.hpp	/^  size_t size() const { return d.size(); }$/;"	f	struct:etr::Vec	typeref:typename:size_t	access:public	signature:() const
etr::Vec::typeTraitD	BufferVector.hpp	/^  using typeTraitD = std::remove_reference<decltype(d)>::type::TypeTrait;$/;"	t	struct:etr::Vec	access:public
etr::VectorTrait	UtilsTraits.hpp	/^struct VectorTrait {};$/;"	s	namespace:etr
etr::acosinus	unaryCalculations.hpp	/^auto acosinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::acosinus	unaryCalculations.hpp	/^auto acosinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,ACosinus,ACosinusTrait>,UnaryTrait>	signature:(const T & obj)
etr::add	Derivs.hpp	/^auto add(const L &l, const R &r) { \/\/ issue: check for scalar. And do what?$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::asinus	unaryCalculations.hpp	/^auto asinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::asinus	unaryCalculations.hpp	/^auto asinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,ASinus,ASinusTrait>,UnaryTrait>	signature:(const T & obj)
etr::ass	UtilsTraits.hpp	/^inline void ass(bool inp, std::string message) {$/;"	f	namespace:etr	typeref:typename:void	signature:(bool inp,std::string message)
etr::at	subsetting.hpp	/^inline BaseType &at(T &inp, R i) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<R,size_t> BaseType &	signature:(T & inp,R i)
etr::at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &&inp, size_t r, size_t c) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> && inp,size_t r,size_t c)
etr::at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, BaseType i_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> & inp,BaseType i_)
etr::at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, BaseType r_, BaseType c_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> & inp,BaseType r_,BaseType c_)
etr::at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, R i) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<R,size_t> BaseType &	signature:(const Vec<BaseType> & inp,R i)
etr::at	subsetting.hpp	/^inline BaseType &at(const Vec<BaseType> &inp, size_t r, size_t c) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(const Vec<BaseType> & inp,size_t r,size_t c)
etr::at	subsetting.hpp	/^template <typename T> inline BaseType &at(T &inp, BaseType i_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(T & inp,BaseType i_)
etr::at	subsetting.hpp	/^template <typename T> inline BaseType &at(T &inp, BaseType r_, BaseType c_) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(T & inp,BaseType r_,BaseType c_)
etr::at	subsetting.hpp	/^template <typename T> inline BaseType &at(T &inp, size_t r, size_t c) {$/;"	f	namespace:etr	typeref:typename:BaseType &	signature:(T & inp,size_t r,size_t c)
etr::atangens	unaryCalculations.hpp	/^auto atangens(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::atangens	unaryCalculations.hpp	/^auto atangens(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,ATangens,ATangensTrait>,UnaryTrait>	signature:(const T & obj)
etr::b2d	UtilsTraits.hpp	/^inline double b2d(bool inp) { return static_cast<double>(inp); }$/;"	f	namespace:etr	typeref:typename:double	signature:(bool inp)
etr::binaryFct	UtilsTraits.hpp	/^typedef double (*binaryFct)(double, double);$/;"	t	namespace:etr	typeref:typename:double (*)(double,double)
etr::calcInd	subsetting.hpp	/^inline void calcInd(T &vec, Indices &ind, const I &idx) {$/;"	f	namespace:etr	typeref:typename:void	signature:(T & vec,Indices & ind,const I & idx)
etr::calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires (std::is_same_v<L,int>||std::is_same_v<L,double>)void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
etr::calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires IsVecBool<L> void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
etr::calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires IsVecDouble<L> void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
etr::calcInd	subsetting.hpp	/^inline void calcInd(const Vec<BaseType> &vec, Indices &ind, MatrixParameter &mp,$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<L,bool> void	signature:(const Vec<BaseType> & vec,Indices & ind,MatrixParameter & mp,const L & idxL,const R & idxR)
etr::cmr	interpolation.hpp	/^inline double cmr(const A &tInp, const B &timeVec, const C &parVec) {$/;"	f	namespace:etr	typeref:typename:double	signature:(const A & tInp,const B & timeVec,const C & parVec)
etr::cmrInternal	interpolation.hpp	/^inline double cmrInternal(const A &tInp, const B &timeVec, const C &parVec) {$/;"	f	namespace:etr	typeref:typename:double	signature:(const A & tInp,const B & timeVec,const C & parVec)
etr::coca	helper.hpp	/^template <typename... Args> inline Vec<BaseType> coca(Args &&...args) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(Args &&...args)
etr::colon	helper.hpp	/^inline Vec<double> colon(const A &start, const O &end) {$/;"	f	namespace:etr	typeref:typename:Vec<double>	signature:(const A & start,const O & end)
etr::convert	UtilsTraits.hpp	/^constexpr doubleWrapper<BoolTrait> convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<T,bool> doubleWrapper<BoolTrait>	signature:(const T & obj)
etr::convert	UtilsTraits.hpp	/^constexpr doubleWrapper<DoubleTrait> convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<T,double> doubleWrapper<DoubleTrait>	signature:(const T & obj)
etr::convert	UtilsTraits.hpp	/^constexpr doubleWrapper<IntTrait> convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:requires std::is_same_v<T,int> doubleWrapper<IntTrait>	signature:(const T & obj)
etr::convert	UtilsTraits.hpp	/^template <typename T> constexpr T convert(const T &obj) {$/;"	f	namespace:etr	typeref:typename:T	signature:(const T & obj)
etr::convertIndentation	UtilsTraits.hpp	/^inline std::string convertIndentation(size_t idx) {$/;"	f	namespace:etr	typeref:typename:std::string	signature:(size_t idx)
etr::convertSize	helper.hpp	/^template <typename T> inline size_t convertSize(const T &inp) {$/;"	f	namespace:etr	typeref:typename:size_t	signature:(const T & inp)
etr::convertSubset	subsetting.hpp	/^Subset<R> convertSubset(const Vec<T, R> &&obj) {$/;"	f	namespace:etr	typeref:typename:Subset<R>	signature:(const Vec<T,R> && obj)
etr::convertSubset	subsetting.hpp	/^Subset<R> convertSubset(const Vec<T, R> &obj) {$/;"	f	namespace:etr	typeref:typename:Subset<R>	signature:(const Vec<T,R> & obj)
etr::convertSubset	subsetting.hpp	/^template <typename T, typename R> Subset<R> convertSubset(Vec<T, R> &obj) {$/;"	f	namespace:etr	typeref:typename:Subset<R>	signature:(Vec<T,R> & obj)
etr::cosinus	unaryCalculations.hpp	/^auto cosinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::cosinus	unaryCalculations.hpp	/^auto cosinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Cosinus,CosinusTrait>,UnaryTrait>	signature:(const T & obj)
etr::cosinush	unaryCalculations.hpp	/^auto cosinush(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::cosinush	unaryCalculations.hpp	/^auto cosinush(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,CosinusH,CosinusHTrait>,UnaryTrait>	signature:(const T & obj)
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R() { return R_NilValue; }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:()
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R(bool res) { return Rf_ScalarLogical(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(bool res)
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R(const Vec<L, R, Trait> &res) {$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(const Vec<L,R,Trait> & res)
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R(const char *res) { return Rf_mkString(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(const char * res)
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R(double res) { return Rf_ScalarReal(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(double res)
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R(int res) { return Rf_ScalarInteger(res); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(int res)
etr::cpp2R	helper.hpp	/^inline SEXP cpp2R(std::string &res) { return Rf_mkString(res.data()); }$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(std::string & res)
etr::cpp2R	helper.hpp	/^template <typename L, typename R> inline SEXP cpp2R(const Vec<L, R> &&res) {$/;"	f	namespace:etr	typeref:typename:SEXP	signature:(const Vec<L,R> && res)
etr::d2b	UtilsTraits.hpp	/^inline bool d2b(double inp) { return static_cast<bool>(inp); }$/;"	f	namespace:etr	typeref:typename:bool	signature:(double inp)
etr::d2i	UtilsTraits.hpp	/^inline int d2i(double inp) { return static_cast<int>(inp); }$/;"	f	namespace:etr	typeref:typename:int	signature:(double inp)
etr::defineMatrix	UtilsTraits.hpp	/^void defineMatrix(const L &l, const R &r, MatrixParameter &mp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(const L & l,const R & r,MatrixParameter & mp)
etr::demangle	UtilsTraits.hpp	/^inline std::string demangle(const char *mangledName) {$/;"	f	namespace:etr	typeref:typename:std::string	signature:(const char * mangledName)
etr::dgamma_etr	distri.hpp	/^inline Vec<BaseType> dgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate,const Vec<BaseType> & lg)
etr::dim	helper.hpp	/^inline Vec<BaseType> dim(const Vec<BaseType> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & inp)
etr::dlnorm_etr	distri.hpp	/^inline Vec<BaseType> dlnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lg)
etr::dnorm_etr	distri.hpp	/^inline Vec<BaseType> dnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lg)
etr::doubleWrapper	UtilsTraits.hpp	/^template <typename Trait = DoubleTrait> struct doubleWrapper {$/;"	s	namespace:etr
etr::doubleWrapper::Type	UtilsTraits.hpp	/^  using Type = DoubleTrait;$/;"	t	struct:etr::doubleWrapper	typeref:typename:DoubleTrait	access:public
etr::doubleWrapper::TypeTrait	UtilsTraits.hpp	/^  using TypeTrait = Trait;$/;"	t	struct:etr::doubleWrapper	typeref:typename:Trait	access:public
etr::doubleWrapper::d	UtilsTraits.hpp	/^  BaseType d;$/;"	m	struct:etr::doubleWrapper	typeref:typename:BaseType	access:public
etr::dunif_etr	distri.hpp	/^inline Vec<BaseType> dunif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lg)
etr::eval	Derivs.hpp	/^inline void eval(AV &av) {$/;"	f	namespace:etr	typeref:typename:requires (IsVec<T> &&!IsVariable<T>)void	signature:(AV & av)
etr::exp	unaryCalculations.hpp	/^auto exp(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::exp	unaryCalculations.hpp	/^auto exp(const T &obj) \/\/ issue: document new function e^x --> exp$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Exp,ExpTrait>,UnaryTrait>	signature:(const T & obj)
etr::extractRetType	UtilsTraits.hpp	/^auto extractRetType(const T &instance) ->$/;"	f	namespace:etr	typeref:typename:T::RetType	signature:(const T & instance)
etr::forEachArg	helper.hpp	/^template <class F, class... Args> inline F forEachArg(F f, Args &&...args) {$/;"	f	namespace:etr	typeref:typename:F	signature:(F f,Args &&...args)
etr::getL	Derivs.hpp	/^template <typename T> constexpr T getL() { return T(); }$/;"	f	namespace:etr	typeref:typename:T	signature:()
etr::getR	Derivs.hpp	/^template <typename T> constexpr T getR() { return T(); }$/;"	f	namespace:etr	typeref:typename:T	signature:()
etr::i2b	UtilsTraits.hpp	/^inline bool i2b(double inp) { return static_cast<bool>(inp); }$/;"	f	namespace:etr	typeref:typename:bool	signature:(double inp)
etr::i2d	UtilsTraits.hpp	/^inline double i2d(int inp) { return static_cast<double>(inp); }$/;"	f	namespace:etr	typeref:typename:double	signature:(int inp)
etr::isDoubleInt	UtilsTraits.hpp	/^template <typename T> inline bool isDoubleInt(const T d) {$/;"	f	namespace:etr	typeref:typename:bool	signature:(const T d)
etr::isInfinite	helper.hpp	/^inline Vec<BaseType> isInfinite(const Vec<BaseType> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & inp)
etr::isNA	helper.hpp	/^inline Vec<bool> isNA(Vec<T, R, Trait> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(Vec<T,R,Trait> & inp)
etr::isNA	helper.hpp	/^inline Vec<bool> isNA(const Vec<T, R, Trait> &&inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(const Vec<T,R,Trait> && inp)
etr::isNA	helper.hpp	/^template <typename T, typename R> inline Vec<bool> isNA(Vec<T, R> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(Vec<T,R> & inp)
etr::isNA	helper.hpp	/^template <typename T, typename R> inline Vec<bool> isNA(const Vec<T, R> &&inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(const Vec<T,R> && inp)
etr::length	helper.hpp	/^inline int length(bool inp) { return 1; }$/;"	f	namespace:etr	typeref:typename:int	signature:(bool inp)
etr::length	helper.hpp	/^inline int length(const Vec<BaseType> &inp) { return inp.size(); }$/;"	f	namespace:etr	typeref:typename:int	signature:(const Vec<BaseType> & inp)
etr::length	helper.hpp	/^inline int length(double inp) { return 1; }$/;"	f	namespace:etr	typeref:typename:int	signature:(double inp)
etr::length	helper.hpp	/^inline int length(int inp) { return 1; }$/;"	f	namespace:etr	typeref:typename:int	signature:(int inp)
etr::length	helper.hpp	/^template <typename L, typename R> inline int length(const Vec<L, R> &inp) {$/;"	f	namespace:etr	typeref:typename:int	signature:(const Vec<L,R> & inp)
etr::li	interpolation.hpp	/^inline double li(const A &t_, const B &timeVec, const C &parVec) {$/;"	f	namespace:etr	typeref:typename:double	signature:(const A & t_,const B & timeVec,const C & parVec)
etr::ln	unaryCalculations.hpp	/^auto ln(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::ln	unaryCalculations.hpp	/^auto ln(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Log,LogTrait>,UnaryTrait>	signature:(const T & obj)
etr::matrix	helper.hpp	/^inline Vec<BaseType> matrix(const V &inp, const R &nrows, const C &ncols) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const V & inp,const R & nrows,const C & ncols)
etr::matrix	helper.hpp	/^inline Vec<BaseType> matrix(int nrows, int ncols) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(int nrows,int ncols)
etr::mul	Derivs.hpp	/^template <typename L, typename R> auto mul(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator !=	binaryCalculations.hpp	/^template <typename L, typename R> auto operator!=(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator *	binaryCalculations.hpp	/^template <typename L, typename R> auto operator*(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator +	binaryCalculations.hpp	/^template <typename L, typename R> auto operator+(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator -	binaryCalculations.hpp	/^template <typename L, typename R> auto operator-(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator -	unaryCalculations.hpp	/^auto operator-(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<BaseType,UnaryOperation<decltype(convert (obj).d) ,MinusUnary,MinusUnaryTrait>,UnaryTrait>	signature:(const T & obj)
etr::operator /	binaryCalculations.hpp	/^template <typename L, typename R> auto operator\/(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator <	binaryCalculations.hpp	/^template <typename L, typename R> auto operator<(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator <<	BufferVector.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const Vec &vec) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const Vec & vec)
etr::operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const BaseStore &b) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const BaseStore & b)
etr::operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const Borrow &b) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const Borrow & b)
etr::operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const BorrowSEXP &b) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const BorrowSEXP & b)
etr::operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const MatrixParameter &m) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const MatrixParameter & m)
etr::operator <=	binaryCalculations.hpp	/^template <typename L, typename R> auto operator<=(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator ==	binaryCalculations.hpp	/^template <typename L, typename R> auto operator==(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator >	binaryCalculations.hpp	/^template <typename L, typename R> auto operator>(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator >=	binaryCalculations.hpp	/^template <typename L, typename R> auto operator>=(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::operator ^	binaryCalculations.hpp	/^template <typename L, typename R> auto operator^(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
etr::pgamma_etr	distri.hpp	/^inline Vec<BaseType> pgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::plnorm_etr	distri.hpp	/^inline Vec<BaseType> plnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::pnorm_etr	distri.hpp	/^inline Vec<BaseType> pnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::print	helper.hpp	/^inline void print() { PRINT_STREAM << std::endl; }$/;"	f	namespace:etr	typeref:typename:void	signature:()
etr::print	helper.hpp	/^inline void print(const T &inp) {$/;"	f	namespace:etr	typeref:typename:requires isBID<T> void	signature:(const T & inp)
etr::print	helper.hpp	/^inline void print(const Vec<L, R> &inp) {$/;"	f	namespace:etr	typeref:typename:requires NotOperation<R> void	signature:(const Vec<L,R> & inp)
etr::print	helper.hpp	/^inline void print(const char *inp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(const char * inp)
etr::print	helper.hpp	/^inline void print(const etr::Vec<T, Op, Trait> &inp) {$/;"	f	namespace:etr	typeref:typename:requires UnaryOrBinaryOperation<Op> void	signature:(const etr::Vec<T,Op,Trait> & inp)
etr::print	helper.hpp	/^print(const T &inp) { \/\/ issue: just a quick fix for printing unary expression$/;"	f	namespace:etr	typeref:typename:requires (!isBID<T>)void	signature:(const T & inp)
etr::printAST	UtilsTraits.hpp	/^template <typename T> inline void printAST(T inp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(T inp)
etr::printT	UtilsTraits.hpp	/^template <typename T> void inline printT() {$/;"	f	namespace:etr	typeref:typename:void	signature:()
etr::printTAST	UtilsTraits.hpp	/^template <typename T> inline void printTAST() {$/;"	f	namespace:etr	typeref:typename:void	signature:()
etr::printType	UtilsTraits.hpp	/^template <typename T> inline void printType(T inp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(T inp)
etr::produceBinaryType	Derivs.hpp	/^produceBinaryType() {$/;"	f	namespace:etr	typeref:typename:BinaryType<LDeriv,RDeriv,Trait,OpTrait>	signature:()
etr::produceQuarternyType	Derivs.hpp	/^produceQuarternyType() {$/;"	f	namespace:etr	typeref:typename:QuarternyType<L,R,LDeriv,RDeriv,Trait,OpTrait>	signature:()
etr::produceRVec	helper.hpp	/^inline auto produceRVec(size_t s) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(size_t s)
etr::produceUnaryType	Derivs.hpp	/^inline constexpr UnaryType<I, Trait, OpTrait> produceUnaryType() {$/;"	f	namespace:etr	typeref:typename:UnaryType<I,Trait,OpTrait>	signature:()
etr::produceVariableType	Derivs.hpp	/^template <typename TRaw> inline constexpr auto produceVariableType() {$/;"	f	namespace:etr	typeref:typename:auto	signature:()
etr::punif_etr	distri.hpp	/^inline Vec<BaseType> punif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::qgamma_etr	distri.hpp	/^inline Vec<BaseType> qgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::qlnorm_etr	distri.hpp	/^inline Vec<BaseType> qlnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::qnorm_etr	distri.hpp	/^inline Vec<BaseType> qnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::quaternaryFct	UtilsTraits.hpp	/^typedef double (*quaternaryFct)(double, double, double, double);$/;"	t	namespace:etr	typeref:typename:double (*)(double,double,double,double)
etr::qunif_etr	distri.hpp	/^inline Vec<BaseType> qunif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
etr::rep	helper.hpp	/^inline Vec<L, Buffer<L, BufferTrait, RBufTrait>, RVecTrait> rep(L inp, R s) {$/;"	f	namespace:etr	typeref:typename:requires std::is_arithmetic_v<L> && std::is_arithmetic_v<R> Vec<L,Buffer<L,BufferTrait,RBufTrait>,RVecTrait>	signature:(L inp,R s)
etr::rep	helper.hpp	/^inline auto rep(L &inp, R &s) {$/;"	f	namespace:etr	typeref:typename:requires IsVec<L> && IsVec<R> auto	signature:(L & inp,R & s)
etr::rep	helper.hpp	/^inline auto rep(L &inp, R s) {$/;"	f	namespace:etr	typeref:typename:requires IsVec<L> && std::is_arithmetic_v<R> auto	signature:(L & inp,R s)
etr::rep	helper.hpp	/^inline auto rep(L &inp, const R &s) {$/;"	f	namespace:etr	typeref:typename:requires IsVec<L> && Operation<R> auto	signature:(L & inp,const R & s)
etr::rep	helper.hpp	/^inline auto rep(L inp, R &s) {$/;"	f	namespace:etr	typeref:typename:requires std::is_arithmetic_v<L> && IsVec<R> auto	signature:(L inp,R & s)
etr::rep	helper.hpp	/^inline auto rep(L inp, const R &s) {$/;"	f	namespace:etr	typeref:typename:requires std::is_arithmetic_v<L> && Operation<R> auto	signature:(L inp,const R & s)
etr::rep	helper.hpp	/^inline auto rep(const L &inp, R &s) {$/;"	f	namespace:etr	typeref:typename:requires Operation<L> && IsVec<R> auto	signature:(const L & inp,R & s)
etr::rep	helper.hpp	/^inline auto rep(const L &inp, R s) {$/;"	f	namespace:etr	typeref:typename:requires Operation<L> && std::is_arithmetic_v<R> auto	signature:(const L & inp,R s)
etr::rep	helper.hpp	/^inline auto rep(const L &inp, const R &s) {$/;"	f	namespace:etr	typeref:typename:requires Operation<L> && Operation<R> auto	signature:(const L & inp,const R & s)
etr::rgamma_etr	distri.hpp	/^inline Vec<BaseType> rgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate)
etr::rlnorm_etr	distri.hpp	/^inline Vec<BaseType> rlnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_)
etr::rnorm_etr	distri.hpp	/^inline Vec<BaseType> rnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_)
etr::runif_etr	distri.hpp	/^inline Vec<BaseType> runif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_)
etr::sinDeriv	Derivs.hpp	/^auto sinDeriv(const L &l) { \/\/ issue: check for scalar. And do what?$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l)
etr::sinus	unaryCalculations.hpp	/^auto sinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::sinus	unaryCalculations.hpp	/^auto sinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Sinus,SinusTrait>,UnaryTrait>	signature:(const T & obj)
etr::sinush	unaryCalculations.hpp	/^auto sinush(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::sinush	unaryCalculations.hpp	/^auto sinush(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,SinusH,SinusHTrait>,UnaryTrait>	signature:(const T & obj)
etr::sqroot	unaryCalculations.hpp	/^auto sqroot(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::sqroot	unaryCalculations.hpp	/^auto sqroot(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,SquareRoot,SquareRootTrait>,UnaryTrait>	signature:(const T & obj)
etr::std::remove_reference<decltype(t)>::type::CaseTrait	UtilsTraits.hpp	/^  typename std::remove_reference<decltype(t)>::type::CaseTrait;$/;"	m	class:etr::std::remove_reference<decltype(t)>::type	typeref:meta:typename
etr::std::remove_reference<decltype(t)>::type::TypeTrait	UtilsTraits.hpp	/^  typename std::remove_reference<decltype(t)>::type::TypeTrait;$/;"	m	class:etr::std::remove_reference<decltype(t)>::type	typeref:meta:typename
etr::subset	subsetting.hpp	/^inline auto subset(Vec<L, R, Trait> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires NotOperation<R> auto	signature:(Vec<L,R,Trait> & vec,const I & idx)
etr::subset	subsetting.hpp	/^inline auto subset(Vec<L, R, Trait> &vec, const IL &idxL, const IR &idxR)$/;"	f	namespace:etr	typeref:typename:Vec<BaseType,Subset<decltype(convert (vec).d) ,SubsetTrait>>	signature:(Vec<L,R,Trait> & vec,const IL & idxL,const IR & idxR)
etr::subset	subsetting.hpp	/^inline auto subset(Vec<L, R> &vec, const I &idx) { \/\/ can this even happen?$/;"	f	namespace:etr	typeref:typename:requires IsRBuf<R> auto	signature:(Vec<L,R> & vec,const I & idx)
etr::subset	subsetting.hpp	/^inline auto subset(Vec<L, R> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires NotOperation<R> auto	signature:(Vec<L,R> & vec,const I & idx)
etr::subset	subsetting.hpp	/^inline auto subset(Vec<T, R> &vec, const IL &idxL, const IR &idxR)$/;"	f	namespace:etr	typeref:typename:Vec<BaseType,Subset<decltype(convert (vec).d) ,SubsetTrait>>	signature:(Vec<T,R> & vec,const IL & idxL,const IR & idxR)
etr::subset	subsetting.hpp	/^inline auto subset(const Vec<L, R, Trait> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires IsRBuf<R> auto	signature:(const Vec<L,R,Trait> & vec,const I & idx)
etr::subset	subsetting.hpp	/^inline auto subset(const Vec<L, R, Trait> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires UnaryOrBinaryOperation<R> auto	signature:(const Vec<L,R,Trait> & vec,const I & idx)
etr::subset	subsetting.hpp	/^inline auto subset(const Vec<L, R, Trait> &vec, const IL &idxL,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<L,R,Trait> & vec,const IL & idxL,const IR & idxR)
etr::subset	subsetting.hpp	/^inline auto subset(const Vec<L, R> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires UnaryOrBinaryOperation<R> auto	signature:(const Vec<L,R> & vec,const I & idx)
etr::subset	subsetting.hpp	/^inline auto subset(const Vec<T, R> &vec, const IL &idxL,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<T,R> & vec,const IL & idxL,const IR & idxR)
etr::tangens	unaryCalculations.hpp	/^auto tangens(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::tangens	unaryCalculations.hpp	/^auto tangens(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Tangens,TangensTrait>,UnaryTrait>	signature:(const T & obj)
etr::tangensh	unaryCalculations.hpp	/^auto tangensh(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
etr::tangensh	unaryCalculations.hpp	/^auto tangensh(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,TangensH,TangensHTrait>,UnaryTrait>	signature:(const T & obj)
etr::vector	helper.hpp	/^template <typename T> inline auto vector(T &inp) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(T & inp)
etr::vector	helper.hpp	/^template <typename T> inline auto vector(const T &inp) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const T & inp)
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT() -> VariableType<T> {$/;"	f	namespace:etr	typeref:typename:VariableType<T>	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT() -> VariableType<T>;$/;"	p	namespace:etr	typeref:typename:VariableType<T>	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires (IsVec<T> &&!IsVariable<T>)auto	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires IsAddition<T> auto	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires IsMultiplication<TRaw> auto	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires IsSinus<T> auto	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT();$/;"	p	namespace:etr	typeref:typename:requires IsAddition<T> auto	signature:()
etr::walkT	Derivs.hpp	/^inline constexpr auto walkT();$/;"	p	namespace:etr	typeref:typename:requires IsMultiplication<T> auto	signature:()
etr::walkT	Derivs.hpp	/^template <typename T> inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:auto	signature:()
etr::warn	UtilsTraits.hpp	/^inline void warn(bool inp, std::string message) {$/;"	f	namespace:etr	typeref:typename:void	signature:(bool inp,std::string message)
eval	Derivs.hpp	/^inline void eval(AV &av) {$/;"	f	namespace:etr	typeref:typename:requires (IsVec<T> &&!IsVariable<T>)void	signature:(AV & av)
exp	unaryCalculations.hpp	/^auto exp(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
exp	unaryCalculations.hpp	/^auto exp(const T &obj) \/\/ issue: document new function e^x --> exp$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Exp,ExpTrait>,UnaryTrait>	signature:(const T & obj)
extractRetType	UtilsTraits.hpp	/^auto extractRetType(const T &instance) ->$/;"	f	namespace:etr	typeref:typename:T::RetType	signature:(const T & instance)
f	UtilsTraits.hpp	/^  f(L a,$/;"	f	struct:etr::EqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::LargerEqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::LargerTrait	typeref:typename:bool	access:public	signature:(L a,R b)
f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::SmallerEqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::SmallerTrait	typeref:typename:bool	access:public	signature:(L a,R b)
f	UtilsTraits.hpp	/^  static bool f(L a, R b) {$/;"	f	struct:etr::UnEqualTrait	typeref:typename:bool	access:public	signature:(L a,R b)
f	UtilsTraits.hpp	/^  static inline auto f(L l, R r) {$/;"	f	struct:etr::DivideTrait	typeref:typename:auto	access:public	signature:(L l,R r)
f	UtilsTraits.hpp	/^  static inline decltype(CommonType<L, R>()) f(L l, R r) { return l + r; }$/;"	f	struct:etr::PlusDerivTrait	typeref:typename:decltype(CommonType<L,R> ())	access:public	signature:(L l,R r)
f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::MinusTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::PlusTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::PowTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
f	UtilsTraits.hpp	/^  static inline std::common_type<L, R>::type f(L l, R r) {$/;"	f	struct:etr::TimesTrait	typeref:typename:std::common_type<L,R>::type	access:public	signature:(L l,R r)
fill	BufferVector.hpp	/^  void fill(T value) { d.fill(value); }$/;"	f	struct:etr::Vec	typeref:typename:void	access:public	signature:(T value)
fill	UtilsTraits.hpp	/^  void fill(T val) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(T val)
fill	UtilsTraits.hpp	/^  void fill(T val) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(T val)
fill	UtilsTraits.hpp	/^  void fill(T val) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(T val)
forEachArg	helper.hpp	/^template <class F, class... Args> inline F forEachArg(F f, Args &&...args) {$/;"	f	namespace:etr	typeref:typename:F	signature:(F f,Args &&...args)
get	Derivs.hpp	/^  auto get() const {$/;"	f	struct:etr::VarPointer	typeref:typename:auto	access:public	signature:() const
getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VarPointer	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VariableType	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t idx) {$/;"	f	struct:etr::BinaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t idx) {$/;"	f	struct:etr::QuarternyType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
getDeriv	Derivs.hpp	/^  template <typename AV> static auto getDeriv(AV &av, size_t idx) {$/;"	f	struct:etr::UnaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
getL	Derivs.hpp	/^template <typename T> constexpr T getL() { return T(); }$/;"	f	namespace:etr	typeref:typename:T	signature:()
getR	Derivs.hpp	/^template <typename T> constexpr T getR() { return T(); }$/;"	f	namespace:etr	typeref:typename:T	signature:()
getRetType	BufferVector.hpp	/^  RetType getRetType() const { return RetType{}; }$/;"	f	struct:etr::Vec	typeref:typename:RetType	access:public	signature:() const
getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::BinaryType	typeref:typename:size_t	access:public	signature:(AV & av)
getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::QuarternyType	typeref:typename:size_t	access:public	signature:(AV & av)
getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::UnaryType	typeref:typename:size_t	access:public	signature:(AV & av)
getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:(AV & av)
getSize	Derivs.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::VariableType	typeref:typename:size_t	access:public	signature:(AV & av)
getSize	binaryCalculations.hpp	/^  template <typename AV> static size_t getSize(AV &av) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:(AV & av)
getSize	unaryCalculations.hpp	/^  template <typename AV> static RetType getSize(AV &av) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:RetType	access:public	signature:(AV & av)
getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VarPointer	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t VecIdx) {$/;"	f	struct:etr::VariableType	typeref:typename:auto	access:public	signature:(AV & av,size_t VecIdx)
getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t idx) {$/;"	f	struct:etr::BinaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t idx) {$/;"	f	struct:etr::QuarternyType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
getVal	Derivs.hpp	/^  template <typename AV> static auto getVal(AV &av, size_t idx) {$/;"	f	struct:etr::UnaryType	typeref:typename:auto	access:public	signature:(AV & av,size_t idx)
getVal	binaryCalculations.hpp	/^  static RetType getVal($/;"	f	struct:etr::BinaryOperation	typeref:typename:RetType	access:public	signature:(AV & av,size_t VecIdx)
getVal	unaryCalculations.hpp	/^  template <typename AV> static RetType getVal(AV &av, size_t VecIdx) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:RetType	access:public	signature:(AV & av,size_t VecIdx)
i2b	UtilsTraits.hpp	/^inline bool i2b(double inp) { return static_cast<bool>(inp); }$/;"	f	namespace:etr	typeref:typename:bool	signature:(double inp)
i2d	UtilsTraits.hpp	/^inline double i2d(int inp) { return static_cast<double>(inp); }$/;"	f	namespace:etr	typeref:typename:double	signature:(int inp)
im	BufferVector.hpp	/^  bool im() const { return d.im(); }$/;"	f	struct:etr::Vec	typeref:typename:bool	access:public	signature:() const
im	Derivs.hpp	/^  bool im() { return AllVarsRef.im(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:bool	access:public	signature:()
im	Derivs.hpp	/^  bool im(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:bool	access:public	signature:(size_t Idx)
im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::BaseStore	typeref:typename:bool	access:public	signature:() const
im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::Borrow	typeref:typename:bool	access:public	signature:() const
im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:bool	access:public	signature:() const
im	UtilsTraits.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::Subset	typeref:typename:bool	access:public	signature:() const
im	UtilsTraits.hpp	/^  bool im() const { return this->ismatrix; }$/;"	f	struct:etr::BaseCalc	typeref:typename:bool	access:public	signature:() const
im	UtilsTraits.hpp	/^  bool im() const { return this->ismatrix; }$/;"	f	struct:etr::MatrixParameter	typeref:typename:bool	access:public	signature:() const
im	binaryCalculations.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::BinaryOperation	typeref:typename:bool	access:public	signature:() const
im	unaryCalculations.hpp	/^  bool im() const { return mp.im(); }$/;"	f	struct:etr::UnaryOperation	typeref:typename:bool	access:public	signature:() const
ind	UtilsTraits.hpp	/^  Indices ind;$/;"	m	struct:etr::Subset	typeref:typename:Indices	access:public
init	UtilsTraits.hpp	/^  void init(T *p, size_t sz) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(T * p,size_t sz)
init	UtilsTraits.hpp	/^  void init(size_t size) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t size)
init	UtilsTraits.hpp	/^  void init(size_t size) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(size_t size)
init	UtilsTraits.hpp	/^  void init(size_t size) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(size_t size)
initBorrow	Derivs.hpp	/^  template <typename... Args> void initBorrow(Args &&...args) {$/;"	f	struct:etr::AllVars	typeref:typename:void	access:public	signature:(Args &&...args)
initBorrowSEXP	Derivs.hpp	/^  template <typename... Args> void initBorrowSEXP(Args &&...args) {$/;"	f	struct:etr::AllVars	typeref:typename:void	access:public	signature:(Args &&...args)
initBuffer	Derivs.hpp	/^  template <typename... Args> void initBuffer(Args &&...args) {$/;"	f	struct:etr::AllVars	typeref:typename:void	access:public	signature:(Args &&...args)
initSEXP	UtilsTraits.hpp	/^  void initSEXP(SEXP s) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(SEXP s)
isBaseTypeRet	BufferVector.hpp	/^      using isBaseTypeRet = std::is_same<RetTypeOtherVec, BaseType>;$/;"	t	function:etr::Vec::operator =	typeref:typename:std::is_same<RetTypeOtherVec,BaseType>
isBinaryOP	BufferVector.hpp	/^  using isBinaryOP = std::is_same<caseTraitD, BinaryTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<caseTraitD,BinaryTrait>	access:public
isBool	subsetting.hpp	/^      using isBool = std::is_same<whichType, bool>;$/;"	t	function:etr::calcInd	typeref:typename:std::is_same<whichType,bool>
isBorrow	BufferVector.hpp	/^  using isBorrow = std::is_same<typeTraitD, BorrowTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,BorrowTrait>	access:public
isBorrowSEXP	BufferVector.hpp	/^  using isBorrowSEXP = std::is_same<typeTraitD, BorrowSEXPTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,BorrowSEXPTrait>	access:public
isBuffer	BufferVector.hpp	/^  using isBuffer = std::is_same<typeTraitD, BufferTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,BufferTrait>	access:public
isDoubleInt	UtilsTraits.hpp	/^template <typename T> inline bool isDoubleInt(const T d) {$/;"	f	namespace:etr	typeref:typename:bool	signature:(const T d)
isDoubleL	UtilsTraits.hpp	/^  using isDoubleL = std::is_same<typeTraitL, DoubleTrait>;$/;"	t	function:etr::defineMatrix	typeref:typename:std::is_same<typeTraitL,DoubleTrait>
isDoubleR	UtilsTraits.hpp	/^  using isDoubleR = std::is_same<typeTraitR, DoubleTrait>;$/;"	t	function:etr::defineMatrix	typeref:typename:std::is_same<typeTraitR,DoubleTrait>
isInfinite	helper.hpp	/^inline Vec<BaseType> isInfinite(const Vec<BaseType> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & inp)
isNA	helper.hpp	/^inline Vec<bool> isNA(Vec<T, R, Trait> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(Vec<T,R,Trait> & inp)
isNA	helper.hpp	/^inline Vec<bool> isNA(const Vec<T, R, Trait> &&inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(const Vec<T,R,Trait> && inp)
isNA	helper.hpp	/^template <typename T, typename R> inline Vec<bool> isNA(Vec<T, R> &inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(Vec<T,R> & inp)
isNA	helper.hpp	/^template <typename T, typename R> inline Vec<bool> isNA(const Vec<T, R> &&inp) {$/;"	f	namespace:etr	typeref:typename:Vec<bool>	signature:(const Vec<T,R> && inp)
isSubset	BufferVector.hpp	/^  using isSubset = std::is_same<typeTraitD, SubsetTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<typeTraitD,SubsetTrait>	access:public
isUnaryOP	BufferVector.hpp	/^  using isUnaryOP = std::is_same<caseTraitD, UnaryTrait>;$/;"	t	struct:etr::Vec	typeref:typename:std::is_same<caseTraitD,UnaryTrait>	access:public
isVec	helper.hpp	/^  using isVec = std::is_same<typeTraitInp, VectorTrait>;$/;"	t	function:etr::dim	typeref:typename:std::is_same<typeTraitInp,VectorTrait>
isVec	subsetting.hpp	/^    using isVec = std::is_same<vecTrait, VectorTrait>;$/;"	t	function:etr::calcInd	typeref:typename:std::is_same<vecTrait,VectorTrait>
isVecA	helper.hpp	/^  using isVecA = std::is_same<typeTraitA, VectorTrait>;$/;"	t	function:etr::colon	typeref:typename:std::is_same<typeTraitA,VectorTrait>
isVecA	interpolation.hpp	/^  using isVecA = std::is_same<typeTraitA, VectorTrait>;$/;"	t	function:etr::cmrInternal	typeref:typename:std::is_same<typeTraitA,VectorTrait>
isVecA	interpolation.hpp	/^  using isVecA = std::is_same<typeTraitA, VectorTrait>;$/;"	t	function:etr::li	typeref:typename:std::is_same<typeTraitA,VectorTrait>
isVecB	interpolation.hpp	/^  using isVecB = std::is_same<typeTraitB, VectorTrait>;$/;"	t	function:etr::cmrInternal	typeref:typename:std::is_same<typeTraitB,VectorTrait>
isVecB	interpolation.hpp	/^  using isVecB = std::is_same<typeTraitB, VectorTrait>;$/;"	t	function:etr::li	typeref:typename:std::is_same<typeTraitB,VectorTrait>
isVecC	interpolation.hpp	/^  using isVecC = std::is_same<typeTraitC, VectorTrait>;$/;"	t	function:etr::cmrInternal	typeref:typename:std::is_same<typeTraitC,VectorTrait>
isVecC	interpolation.hpp	/^  using isVecC = std::is_same<typeTraitC, VectorTrait>;$/;"	t	function:etr::li	typeref:typename:std::is_same<typeTraitC,VectorTrait>
isVecO	helper.hpp	/^  using isVecO = std::is_same<typeTraitO, VectorTrait>;$/;"	t	function:etr::colon	typeref:typename:std::is_same<typeTraitO,VectorTrait>
ismatrix	UtilsTraits.hpp	/^  bool ismatrix = false;$/;"	m	struct:etr::MatrixParameter	typeref:typename:bool	access:public
ismatrix	UtilsTraits.hpp	/^  bool ismatrix;$/;"	m	struct:etr::BaseCalc	typeref:typename:bool	access:public
l	binaryCalculations.hpp	/^  const L &l;$/;"	m	struct:etr::BinaryOperation	typeref:typename:const L &	access:public
length	helper.hpp	/^inline int length(bool inp) { return 1; }$/;"	f	namespace:etr	typeref:typename:int	signature:(bool inp)
length	helper.hpp	/^inline int length(const Vec<BaseType> &inp) { return inp.size(); }$/;"	f	namespace:etr	typeref:typename:int	signature:(const Vec<BaseType> & inp)
length	helper.hpp	/^inline int length(double inp) { return 1; }$/;"	f	namespace:etr	typeref:typename:int	signature:(double inp)
length	helper.hpp	/^inline int length(int inp) { return 1; }$/;"	f	namespace:etr	typeref:typename:int	signature:(int inp)
length	helper.hpp	/^template <typename L, typename R> inline int length(const Vec<L, R> &inp) {$/;"	f	namespace:etr	typeref:typename:int	signature:(const Vec<L,R> & inp)
li	interpolation.hpp	/^inline double li(const A &t_, const B &timeVec, const C &parVec) {$/;"	f	namespace:etr	typeref:typename:double	signature:(const A & t_,const B & timeVec,const C & parVec)
ln	unaryCalculations.hpp	/^auto ln(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
ln	unaryCalculations.hpp	/^auto ln(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Log,LogTrait>,UnaryTrait>	signature:(const T & obj)
matrix	helper.hpp	/^inline Vec<BaseType> matrix(const V &inp, const R &nrows, const C &ncols) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const V & inp,const R & nrows,const C & ncols)
matrix	helper.hpp	/^inline Vec<BaseType> matrix(int nrows, int ncols) {$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(int nrows,int ncols)
moveit	UtilsTraits.hpp	/^  template <typename L2> BaseStore &moveit(L2 &other) {$/;"	f	struct:etr::BaseStore	typeref:typename:BaseStore &	access:public	signature:(L2 & other)
moveit	UtilsTraits.hpp	/^  template <typename L2> Borrow &moveit(L2 &other) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:Borrow &	access:public	signature:(L2 & other)
moveit	UtilsTraits.hpp	/^  template <typename L2> BorrowSEXP &moveit(L2 &other) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXP &	access:public	signature:(L2 & other)
mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::BaseStore	typeref:typename:MatrixParameter	access:public
mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::Borrow	typeref:typename:MatrixParameter	access:public
mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:MatrixParameter	access:public
mp	UtilsTraits.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::Subset	typeref:typename:MatrixParameter	access:public
mp	binaryCalculations.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::BinaryOperation	typeref:typename:MatrixParameter	access:public
mp	unaryCalculations.hpp	/^  MatrixParameter mp;$/;"	m	struct:etr::UnaryOperation	typeref:typename:MatrixParameter	access:public
mul	Derivs.hpp	/^template <typename L, typename R> auto mul(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
nc	BufferVector.hpp	/^  size_t nc() const { return d.nc(); }$/;"	f	struct:etr::Vec	typeref:typename:size_t	access:public	signature:() const
nc	Derivs.hpp	/^  size_t nc() { return AllVarsRef.nc(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:()
nc	Derivs.hpp	/^  std::size_t nc(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:std::size_t	access:public	signature:(size_t Idx)
nc	UtilsTraits.hpp	/^  size_t nc() const { return cols; }$/;"	f	struct:etr::BaseCalc	typeref:typename:size_t	access:public	signature:() const
nc	UtilsTraits.hpp	/^  size_t nc() const { return cols; }$/;"	f	struct:etr::MatrixParameter	typeref:typename:size_t	access:public	signature:() const
nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::BaseStore	typeref:typename:size_t	access:public	signature:() const
nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::Borrow	typeref:typename:size_t	access:public	signature:() const
nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public	signature:() const
nc	UtilsTraits.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::Subset	typeref:typename:size_t	access:public	signature:() const
nc	binaryCalculations.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:() const
nc	unaryCalculations.hpp	/^  size_t nc() const { return mp.nc(); }$/;"	f	struct:etr::UnaryOperation	typeref:typename:size_t	access:public	signature:() const
nr	BufferVector.hpp	/^  size_t nr() const { return d.nr(); }$/;"	f	struct:etr::Vec	typeref:typename:size_t	access:public	signature:() const
nr	Derivs.hpp	/^  size_t nr() { return AllVarsRef.nr(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:()
nr	Derivs.hpp	/^  std::size_t nr(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:std::size_t	access:public	signature:(size_t Idx)
nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::BaseStore	typeref:typename:size_t	access:public	signature:() const
nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::Borrow	typeref:typename:size_t	access:public	signature:() const
nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public	signature:() const
nr	UtilsTraits.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::Subset	typeref:typename:size_t	access:public	signature:() const
nr	UtilsTraits.hpp	/^  size_t nr() const { return rows; }$/;"	f	struct:etr::BaseCalc	typeref:typename:size_t	access:public	signature:() const
nr	UtilsTraits.hpp	/^  size_t nr() const { return rows; }$/;"	f	struct:etr::MatrixParameter	typeref:typename:size_t	access:public	signature:() const
nr	binaryCalculations.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:() const
nr	unaryCalculations.hpp	/^  size_t nr() const { return mp.nr(); }$/;"	f	struct:etr::UnaryOperation	typeref:typename:size_t	access:public	signature:() const
obj	unaryCalculations.hpp	/^  const I &obj;$/;"	m	struct:etr::UnaryOperation	typeref:typename:const I &	access:public
operator !=	UtilsTraits.hpp	/^  bool operator!=(const It &rhs) { return p != rhs.p; }$/;"	f	struct:etr::It	typeref:typename:bool	access:public	signature:(const It & rhs)
operator !=	binaryCalculations.hpp	/^template <typename L, typename R> auto operator!=(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator ()	BufferVector.hpp	/^  auto operator()(const IL &idxL, const IR &idxR) {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:(const IL & idxL,const IR & idxR)
operator ()	BufferVector.hpp	/^  template <typename I> auto operator()(const I &idx) {$/;"	f	struct:etr::Vec	typeref:typename:auto	access:public	signature:(const I & idx)
operator *	UtilsTraits.hpp	/^  T &operator*() { return *p; }$/;"	f	struct:etr::It	typeref:typename:T &	access:public	signature:()
operator *	binaryCalculations.hpp	/^template <typename L, typename R> auto operator*(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator +	binaryCalculations.hpp	/^template <typename L, typename R> auto operator+(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator ++	UtilsTraits.hpp	/^  void operator++() { ++p; }$/;"	f	struct:etr::It	typeref:typename:void	access:public	signature:()
operator -	binaryCalculations.hpp	/^template <typename L, typename R> auto operator-(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator -	unaryCalculations.hpp	/^auto operator-(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<BaseType,UnaryOperation<decltype(convert (obj).d) ,MinusUnary,MinusUnaryTrait>,UnaryTrait>	signature:(const T & obj)
operator /	binaryCalculations.hpp	/^template <typename L, typename R> auto operator\/(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator <	binaryCalculations.hpp	/^template <typename L, typename R> auto operator<(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator <<	BufferVector.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const Vec &vec) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const Vec & vec)
operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const BaseStore &b) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const BaseStore & b)
operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const Borrow &b) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const Borrow & b)
operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const BorrowSEXP &b) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const BorrowSEXP & b)
operator <<	UtilsTraits.hpp	/^  friend std::ostream &operator<<(std::ostream &os, const MatrixParameter &m) {$/;"	f	namespace:etr	typeref:typename:std::ostream &	signature:(std::ostream & os,const MatrixParameter & m)
operator <=	binaryCalculations.hpp	/^template <typename L, typename R> auto operator<=(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator =	BufferVector.hpp	/^  Vec &operator=(Rcpp::NumericMatrix &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(Rcpp::NumericMatrix & otherVec)
operator =	BufferVector.hpp	/^  Vec &operator=(Rcpp::NumericVector &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(Rcpp::NumericVector & otherVec)
operator =	BufferVector.hpp	/^  Vec &operator=(SEXP s) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(SEXP s)
operator =	BufferVector.hpp	/^  Vec &operator=(Vec<BaseType> &other) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(Vec<BaseType> & other)
operator =	BufferVector.hpp	/^  Vec &operator=(arma::mat &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(arma::mat & otherVec)
operator =	BufferVector.hpp	/^  Vec &operator=(arma::vec &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(arma::vec & otherVec)
operator =	BufferVector.hpp	/^  Vec &operator=(const T inp) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(const T inp)
operator =	BufferVector.hpp	/^  Vec &operator=(const TD inp) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<TD,bool> Vec &	access:public	signature:(const TD inp)
operator =	BufferVector.hpp	/^  Vec &operator=(const TD inp) {$/;"	f	struct:etr::Vec	typeref:typename:requires std::is_same_v<TD,int> Vec &	access:public	signature:(const TD inp)
operator =	BufferVector.hpp	/^  Vec &operator=(const Vec<T, R, Trait> &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(const Vec<T,R,Trait> & otherVec)
operator =	BufferVector.hpp	/^  Vec &operator=(const Vec<T2, R2, Trait2> &otherVec) {$/;"	f	struct:etr::Vec	typeref:typename:Vec &	access:public	signature:(const Vec<T2,R2,Trait2> & otherVec)
operator =	UtilsTraits.hpp	/^  BaseStore &operator=(const BaseStore<T> &other) { \/\/ deep copy$/;"	f	struct:etr::BaseStore	typeref:typename:BaseStore &	access:public	signature:(const BaseStore<T> & other)
operator =	UtilsTraits.hpp	/^  Borrow &operator=(const Borrow<T> &other) {$/;"	f	struct:etr::Borrow	typeref:typename:Borrow &	access:public	signature:(const Borrow<T> & other)
operator =	UtilsTraits.hpp	/^  BorrowSEXP &operator=(SEXP inp) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXP &	access:public	signature:(SEXP inp)
operator =	UtilsTraits.hpp	/^  BorrowSEXP &operator=(const BorrowSEXP<T> &other) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:BorrowSEXP &	access:public	signature:(const BorrowSEXP<T> & other)
operator ==	binaryCalculations.hpp	/^template <typename L, typename R> auto operator==(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator >	binaryCalculations.hpp	/^template <typename L, typename R> auto operator>(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator >=	binaryCalculations.hpp	/^template <typename L, typename R> auto operator>=(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator Rcpp::NumericMatrix	BufferVector.hpp	/^  operator Rcpp::NumericMatrix() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
operator Rcpp::NumericVector	BufferVector.hpp	/^  operator Rcpp::NumericVector() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
operator RetType	BufferVector.hpp	/^  operator RetType() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
operator []	BufferVector.hpp	/^  RetType &operator[](size_t idx) { return d[idx]; }$/;"	f	struct:etr::Vec	typeref:typename:RetType &	access:public	signature:(size_t idx)
operator []	BufferVector.hpp	/^  RetType operator[](size_t idx) const { return d[idx]; }$/;"	f	struct:etr::Vec	typeref:typename:RetType	access:public	signature:(size_t idx) const
operator []	UtilsTraits.hpp	/^  CurrentBaseType &operator[](size_t pos) {$/;"	f	struct:etr::Subset	typeref:typename:CurrentBaseType &	access:public	signature:(size_t pos)
operator []	UtilsTraits.hpp	/^  CurrentBaseType operator[](size_t pos) const {$/;"	f	struct:etr::Subset	typeref:typename:CurrentBaseType	access:public	signature:(size_t pos) const
operator []	UtilsTraits.hpp	/^  RetType &operator[](size_t idx) {$/;"	f	struct:etr::BaseStore	typeref:typename:RetType &	access:public	signature:(size_t idx)
operator []	UtilsTraits.hpp	/^  RetType &operator[](size_t idx) {$/;"	f	struct:etr::Borrow	typeref:typename:RetType &	access:public	signature:(size_t idx)
operator []	UtilsTraits.hpp	/^  RetType &operator[](size_t pos) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:RetType &	access:public	signature:(size_t pos)
operator []	UtilsTraits.hpp	/^  RetType operator[](size_t idx) const {$/;"	f	struct:etr::BaseStore	typeref:typename:RetType	access:public	signature:(size_t idx) const
operator []	UtilsTraits.hpp	/^  RetType operator[](size_t idx) const {$/;"	f	struct:etr::Borrow	typeref:typename:RetType	access:public	signature:(size_t idx) const
operator []	UtilsTraits.hpp	/^  RetType operator[](size_t pos) const {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:RetType	access:public	signature:(size_t pos) const
operator []	binaryCalculations.hpp	/^  auto operator[](size_t i) const { \/\/ RetType is not suitable as int \/ int -_> should return/;"	f	struct:etr::BinaryOperation	typeref:typename:auto	access:public	signature:(size_t i) const
operator []	unaryCalculations.hpp	/^  RetType operator[](size_t i) const {$/;"	f	struct:etr::UnaryOperation	typeref:typename:RetType	access:public	signature:(size_t i) const
operator ^	binaryCalculations.hpp	/^template <typename L, typename R> auto operator^(const L &l, const R &r) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l,const R & r)
operator arma::mat	BufferVector.hpp	/^  operator arma::mat() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
operator arma::vec	BufferVector.hpp	/^  operator arma::vec() const {$/;"	f	struct:etr::Vec	access:public	signature:() const
p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::BaseStore	typeref:typename:T *	access:public
p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::Borrow	typeref:typename:T *	access:public
p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:T *	access:public
p	UtilsTraits.hpp	/^  T *p = nullptr;$/;"	m	struct:etr::Subset	typeref:typename:T *	access:public
p	UtilsTraits.hpp	/^  T *p;$/;"	m	struct:etr::It	typeref:typename:T *	access:public
pgamma_etr	distri.hpp	/^inline Vec<BaseType> pgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
plnorm_etr	distri.hpp	/^inline Vec<BaseType> plnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
pnorm_etr	distri.hpp	/^inline Vec<BaseType> pnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
print	helper.hpp	/^inline void print() { PRINT_STREAM << std::endl; }$/;"	f	namespace:etr	typeref:typename:void	signature:()
print	helper.hpp	/^inline void print(const T &inp) {$/;"	f	namespace:etr	typeref:typename:requires isBID<T> void	signature:(const T & inp)
print	helper.hpp	/^inline void print(const Vec<L, R> &inp) {$/;"	f	namespace:etr	typeref:typename:requires NotOperation<R> void	signature:(const Vec<L,R> & inp)
print	helper.hpp	/^inline void print(const char *inp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(const char * inp)
print	helper.hpp	/^inline void print(const etr::Vec<T, Op, Trait> &inp) {$/;"	f	namespace:etr	typeref:typename:requires UnaryOrBinaryOperation<Op> void	signature:(const etr::Vec<T,Op,Trait> & inp)
print	helper.hpp	/^print(const T &inp) { \/\/ issue: just a quick fix for printing unary expression$/;"	f	namespace:etr	typeref:typename:requires (!isBID<T>)void	signature:(const T & inp)
printAST	UtilsTraits.hpp	/^template <typename T> inline void printAST(T inp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(T inp)
printT	UtilsTraits.hpp	/^template <typename T> void inline printT() {$/;"	f	namespace:etr	typeref:typename:void	signature:()
printTAST	UtilsTraits.hpp	/^template <typename T> inline void printTAST() {$/;"	f	namespace:etr	typeref:typename:void	signature:()
printType	UtilsTraits.hpp	/^template <typename T> inline void printType(T inp) {$/;"	f	namespace:etr	typeref:typename:void	signature:(T inp)
produceBinaryType	Derivs.hpp	/^produceBinaryType() {$/;"	f	namespace:etr	typeref:typename:BinaryType<LDeriv,RDeriv,Trait,OpTrait>	signature:()
produceQuarternyType	Derivs.hpp	/^produceQuarternyType() {$/;"	f	namespace:etr	typeref:typename:QuarternyType<L,R,LDeriv,RDeriv,Trait,OpTrait>	signature:()
produceRVec	helper.hpp	/^inline auto produceRVec(size_t s) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(size_t s)
produceUnaryType	Derivs.hpp	/^inline constexpr UnaryType<I, Trait, OpTrait> produceUnaryType() {$/;"	f	namespace:etr	typeref:typename:UnaryType<I,Trait,OpTrait>	signature:()
produceVariableType	Derivs.hpp	/^template <typename TRaw> inline constexpr auto produceVariableType() {$/;"	f	namespace:etr	typeref:typename:auto	signature:()
punif_etr	distri.hpp	/^inline Vec<BaseType> punif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
push_back	UtilsTraits.hpp	/^  void push_back(T input) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:void	access:public	signature:(T input)
push_back	UtilsTraits.hpp	/^  void push_back(T input) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(T input)
push_back	UtilsTraits.hpp	/^  void push_back(T input) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(T input)
qgamma_etr	distri.hpp	/^inline Vec<BaseType> qgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
qlnorm_etr	distri.hpp	/^inline Vec<BaseType> qlnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
qnorm_etr	distri.hpp	/^inline Vec<BaseType> qnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
quaternaryFct	UtilsTraits.hpp	/^typedef double (*quaternaryFct)(double, double, double, double);$/;"	t	namespace:etr	typeref:typename:double (*)(double,double,double,double)
qunif_etr	distri.hpp	/^inline Vec<BaseType> qunif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_,const Vec<BaseType> & lower,const Vec<BaseType> & lg)
r	binaryCalculations.hpp	/^  const R &r;$/;"	m	struct:etr::BinaryOperation	typeref:typename:const R &	access:public
realloc	UtilsTraits.hpp	/^  void realloc(int new_size) = delete;$/;"	p	struct:etr::Borrow	typeref:typename:void	access:public	signature:(int new_size)
realloc	UtilsTraits.hpp	/^  void realloc(int new_size) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(int new_size)
realloc	UtilsTraits.hpp	/^  void realloc(size_t newSize) { p->realloc(newSize); }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(size_t newSize)
realloc	UtilsTraits.hpp	/^  void realloc(size_t new_size) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(size_t new_size)
rep	helper.hpp	/^inline Vec<L, Buffer<L, BufferTrait, RBufTrait>, RVecTrait> rep(L inp, R s) {$/;"	f	namespace:etr	typeref:typename:requires std::is_arithmetic_v<L> && std::is_arithmetic_v<R> Vec<L,Buffer<L,BufferTrait,RBufTrait>,RVecTrait>	signature:(L inp,R s)
rep	helper.hpp	/^inline auto rep(L &inp, R &s) {$/;"	f	namespace:etr	typeref:typename:requires IsVec<L> && IsVec<R> auto	signature:(L & inp,R & s)
rep	helper.hpp	/^inline auto rep(L &inp, R s) {$/;"	f	namespace:etr	typeref:typename:requires IsVec<L> && std::is_arithmetic_v<R> auto	signature:(L & inp,R s)
rep	helper.hpp	/^inline auto rep(L &inp, const R &s) {$/;"	f	namespace:etr	typeref:typename:requires IsVec<L> && Operation<R> auto	signature:(L & inp,const R & s)
rep	helper.hpp	/^inline auto rep(L inp, R &s) {$/;"	f	namespace:etr	typeref:typename:requires std::is_arithmetic_v<L> && IsVec<R> auto	signature:(L inp,R & s)
rep	helper.hpp	/^inline auto rep(L inp, const R &s) {$/;"	f	namespace:etr	typeref:typename:requires std::is_arithmetic_v<L> && Operation<R> auto	signature:(L inp,const R & s)
rep	helper.hpp	/^inline auto rep(const L &inp, R &s) {$/;"	f	namespace:etr	typeref:typename:requires Operation<L> && IsVec<R> auto	signature:(const L & inp,R & s)
rep	helper.hpp	/^inline auto rep(const L &inp, R s) {$/;"	f	namespace:etr	typeref:typename:requires Operation<L> && std::is_arithmetic_v<R> auto	signature:(const L & inp,R s)
rep	helper.hpp	/^inline auto rep(const L &inp, const R &s) {$/;"	f	namespace:etr	typeref:typename:requires Operation<L> && Operation<R> auto	signature:(const L & inp,const R & s)
resize	BufferVector.hpp	/^  void resize(size_t newSize) { d.resize(newSize); }$/;"	f	struct:etr::Vec	typeref:typename:void	access:public	signature:(size_t newSize)
resize	UtilsTraits.hpp	/^  void resize(size_t newSize) { p->resize(newSize); }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(size_t newSize)
resize	UtilsTraits.hpp	/^  void resize(size_t newSize) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(size_t newSize)
resize	UtilsTraits.hpp	/^  void resize(size_t newSize) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t newSize)
resize	UtilsTraits.hpp	/^  void resize(size_t newSize) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(size_t newSize)
resizeInd	UtilsTraits.hpp	/^  void resizeInd(int newSize) { ind.resize(newSize); }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(int newSize)
ret	UtilsTraits.hpp	/^  using ret = typename T::RetType;$/;"	t	function:etr::extractRetType	typeref:typename:T::RetType
rgamma_etr	distri.hpp	/^inline Vec<BaseType> rgamma_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & shape,const Vec<BaseType> & rate)
rlnorm_etr	distri.hpp	/^inline Vec<BaseType> rlnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_)
rnorm_etr	distri.hpp	/^inline Vec<BaseType> rnorm_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_)
rows	UtilsTraits.hpp	/^  size_t rows = 0;$/;"	m	struct:etr::MatrixParameter	typeref:typename:size_t	access:public
rows	UtilsTraits.hpp	/^  size_t rows;$/;"	m	struct:etr::BaseCalc	typeref:typename:size_t	access:public
runif_etr	distri.hpp	/^inline Vec<BaseType> runif_etr(const Vec<BaseType> &x,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<BaseType> & x,const Vec<BaseType> & min_,const Vec<BaseType> & max_)
set	UtilsTraits.hpp	/^  void set(size_t idx, T val) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t idx,T val)
setInd	UtilsTraits.hpp	/^  void setInd(int idx, int val) { ind[idx] = val; }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(int idx,int val)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BorrowSEXP	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::MatrixParameter	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::BaseStore	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::MatrixParameter	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
setMatrix	UtilsTraits.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
setMatrix	binaryCalculations.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
setMatrix	binaryCalculations.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	binaryCalculations.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::BinaryOperation	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
setMatrix	unaryCalculations.hpp	/^  void setMatrix(MatrixParameter &mp_) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:void	access:public	signature:(MatrixParameter & mp_)
setMatrix	unaryCalculations.hpp	/^  void setMatrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
setMatrix	unaryCalculations.hpp	/^  void setMatrix(const MatrixParameter &mp_) {$/;"	f	struct:etr::UnaryOperation	typeref:typename:void	access:public	signature:(const MatrixParameter & mp_)
setPtr	UtilsTraits.hpp	/^  void setPtr(const T *pOther) { this->p = pOther; }$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(const T * pOther)
setPtr	UtilsTraits.hpp	/^  void setPtr(const T *pOther) { this->p = pOther; }$/;"	f	struct:etr::Subset	typeref:typename:void	access:public	signature:(const T * pOther)
setSize	UtilsTraits.hpp	/^  void setSize(size_t sz_) { this->sz = sz_; }$/;"	f	struct:etr::Borrow	typeref:typename:void	access:public	signature:(size_t sz_)
set_matrix	UtilsTraits.hpp	/^  void set_matrix(bool i, size_t nrow, size_t ncol) {$/;"	f	struct:etr::BaseCalc	typeref:typename:void	access:public	signature:(bool i,size_t nrow,size_t ncol)
sinDeriv	Derivs.hpp	/^auto sinDeriv(const L &l) { \/\/ issue: check for scalar. And do what?$/;"	f	namespace:etr	typeref:typename:auto	signature:(const L & l)
sinus	unaryCalculations.hpp	/^auto sinus(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
sinus	unaryCalculations.hpp	/^auto sinus(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Sinus,SinusTrait>,UnaryTrait>	signature:(const T & obj)
sinush	unaryCalculations.hpp	/^auto sinush(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
sinush	unaryCalculations.hpp	/^auto sinush(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,SinusH,SinusHTrait>,UnaryTrait>	signature:(const T & obj)
size	BufferVector.hpp	/^  size_t size() const { return d.size(); }$/;"	f	struct:etr::Vec	typeref:typename:size_t	access:public	signature:() const
size	Derivs.hpp	/^  size_t size() { return AllVarsRef.size(Idx); }$/;"	f	struct:etr::VarPointer	typeref:typename:size_t	access:public	signature:()
size	Derivs.hpp	/^  std::size_t size(size_t Idx) {$/;"	f	struct:etr::AllVars	typeref:typename:std::size_t	access:public	signature:(size_t Idx)
size	UtilsTraits.hpp	/^  size_t size() const { return ind.size(); }$/;"	f	struct:etr::Subset	typeref:typename:size_t	access:public	signature:() const
size	UtilsTraits.hpp	/^  size_t size() const { return sz; }$/;"	f	struct:etr::BaseStore	typeref:typename:size_t	access:public	signature:() const
size	UtilsTraits.hpp	/^  size_t size() const { return sz; }$/;"	f	struct:etr::Borrow	typeref:typename:size_t	access:public	signature:() const
size	UtilsTraits.hpp	/^  size_t size() const { return sz; }$/;"	f	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public	signature:() const
size	binaryCalculations.hpp	/^  size_t size() const {$/;"	f	struct:etr::BinaryOperation	typeref:typename:size_t	access:public	signature:() const
size	unaryCalculations.hpp	/^  size_t size() const {$/;"	f	struct:etr::UnaryOperation	typeref:typename:size_t	access:public	signature:() const
sqroot	unaryCalculations.hpp	/^auto sqroot(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
sqroot	unaryCalculations.hpp	/^auto sqroot(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,SquareRoot,SquareRootTrait>,UnaryTrait>	signature:(const T & obj)
subset	subsetting.hpp	/^inline auto subset(Vec<L, R, Trait> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires NotOperation<R> auto	signature:(Vec<L,R,Trait> & vec,const I & idx)
subset	subsetting.hpp	/^inline auto subset(Vec<L, R, Trait> &vec, const IL &idxL, const IR &idxR)$/;"	f	namespace:etr	typeref:typename:Vec<BaseType,Subset<decltype(convert (vec).d) ,SubsetTrait>>	signature:(Vec<L,R,Trait> & vec,const IL & idxL,const IR & idxR)
subset	subsetting.hpp	/^inline auto subset(Vec<L, R> &vec, const I &idx) { \/\/ can this even happen?$/;"	f	namespace:etr	typeref:typename:requires IsRBuf<R> auto	signature:(Vec<L,R> & vec,const I & idx)
subset	subsetting.hpp	/^inline auto subset(Vec<L, R> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires NotOperation<R> auto	signature:(Vec<L,R> & vec,const I & idx)
subset	subsetting.hpp	/^inline auto subset(Vec<T, R> &vec, const IL &idxL, const IR &idxR)$/;"	f	namespace:etr	typeref:typename:Vec<BaseType,Subset<decltype(convert (vec).d) ,SubsetTrait>>	signature:(Vec<T,R> & vec,const IL & idxL,const IR & idxR)
subset	subsetting.hpp	/^inline auto subset(const Vec<L, R, Trait> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires IsRBuf<R> auto	signature:(const Vec<L,R,Trait> & vec,const I & idx)
subset	subsetting.hpp	/^inline auto subset(const Vec<L, R, Trait> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires UnaryOrBinaryOperation<R> auto	signature:(const Vec<L,R,Trait> & vec,const I & idx)
subset	subsetting.hpp	/^inline auto subset(const Vec<L, R, Trait> &vec, const IL &idxL,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<L,R,Trait> & vec,const IL & idxL,const IR & idxR)
subset	subsetting.hpp	/^inline auto subset(const Vec<L, R> &vec, const I &idx) {$/;"	f	namespace:etr	typeref:typename:requires UnaryOrBinaryOperation<R> auto	signature:(const Vec<L,R> & vec,const I & idx)
subset	subsetting.hpp	/^inline auto subset(const Vec<T, R> &vec, const IL &idxL,$/;"	f	namespace:etr	typeref:typename:Vec<BaseType>	signature:(const Vec<T,R> & vec,const IL & idxL,const IR & idxR)
sz	UtilsTraits.hpp	/^  size_t sz = 0;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:size_t	access:public
sz	UtilsTraits.hpp	/^  size_t sz = 1;$/;"	m	struct:etr::BaseStore	typeref:typename:size_t	access:public
sz	UtilsTraits.hpp	/^  size_t sz = 1;$/;"	m	struct:etr::Borrow	typeref:typename:size_t	access:public
tD	Derivs.hpp	/^    using tD = ExtractedTypeD<T>;$/;"	t	function:etr::produceVariableType	typeref:typename:ExtractedTypeD<T>
tD	Derivs.hpp	/^  using tD = ExtractedDType<cleanType>;$/;"	t	function:etr::walkT	typeref:typename:ExtractedDType<cleanType>
tD	Derivs.hpp	/^  using tD = ExtractedTypeD<T>;$/;"	t	function:etr::eval	typeref:typename:ExtractedTypeD<T>
tD	Derivs.hpp	/^  using tD = ExtractedTypeD<T>;$/;"	t	function:etr::walkT	typeref:typename:ExtractedTypeD<T>
tangens	unaryCalculations.hpp	/^auto tangens(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
tangens	unaryCalculations.hpp	/^auto tangens(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,Tangens,TangensTrait>,UnaryTrait>	signature:(const T & obj)
tangensh	unaryCalculations.hpp	/^auto tangensh(const T &obj) -> BaseType {$/;"	f	namespace:etr	typeref:typename:BaseType	signature:(const T & obj)
tangensh	unaryCalculations.hpp	/^auto tangensh(const T &obj)$/;"	f	namespace:etr	typeref:typename:Vec<double,UnaryOperation<decltype(convert (obj).d) ,TangensH,TangensHTrait>,UnaryTrait>	signature:(const T & obj)
todelete	UtilsTraits.hpp	/^  bool todelete = false;$/;"	m	struct:etr::BorrowSEXP	typeref:typename:bool	access:public
type	Derivs.hpp	/^  using type = R const;$/;"	t	struct:etr::ExtractTypeD	typeref:typename:R const	access:public
type	Derivs.hpp	/^  using type = R;$/;"	t	struct:etr::ExtractDType	typeref:typename:R	access:public
type	Derivs.hpp	/^  using type = R;$/;"	t	struct:etr::ExtractTypeD	typeref:typename:R	access:public
type	Derivs.hpp	/^  using type = TypeTrait;$/;"	t	struct:etr::ExtractTypeTrait	typeref:typename:TypeTrait	access:public
type	Derivs.hpp	/^  using type = std::false_type;$/;"	t	struct:etr::ExtractTypeTrait	typeref:typename:std::false_type	access:public
typeTraitA	helper.hpp	/^  using typeTraitA =$/;"	t	function:etr::colon
typeTraitA	interpolation.hpp	/^  using typeTraitA = std::remove_reference<decltype(tInp)>::type::TypeTrait;$/;"	t	function:etr::cmrInternal
typeTraitA	interpolation.hpp	/^  using typeTraitA = std::remove_reference<decltype(t_)>::type::TypeTrait;$/;"	t	function:etr::li
typeTraitB	interpolation.hpp	/^  using typeTraitB = std::remove_reference<decltype(timeVec)>::type::TypeTrait;$/;"	t	function:etr::cmrInternal
typeTraitB	interpolation.hpp	/^  using typeTraitB = std::remove_reference<decltype(timeVec)>::type::TypeTrait;$/;"	t	function:etr::li
typeTraitC	interpolation.hpp	/^  using typeTraitC = std::remove_reference<decltype(parVec)>::type::TypeTrait;$/;"	t	function:etr::cmrInternal
typeTraitC	interpolation.hpp	/^  using typeTraitC = std::remove_reference<decltype(parVec)>::type::TypeTrait;$/;"	t	function:etr::li
typeTraitD	BufferVector.hpp	/^  using typeTraitD = std::remove_reference<decltype(d)>::type::TypeTrait;$/;"	t	struct:etr::Vec	access:public
typeTraitInp	helper.hpp	/^  using typeTraitInp = std::remove_reference<decltype(inp)>::type::TypeTrait;$/;"	t	function:etr::dim
typeTraitL	Derivs.hpp	/^  using typeTraitL = L;$/;"	t	struct:etr::QuarternyType	typeref:typename:L	access:public
typeTraitL	UtilsTraits.hpp	/^  using typeTraitL = std::remove_reference<decltype(convert(l))>::type::Type;$/;"	t	function:etr::defineMatrix
typeTraitL	binaryCalculations.hpp	/^  using typeTraitL = L;$/;"	t	struct:etr::BinaryOperation	typeref:typename:L	access:public
typeTraitLDeriv	Derivs.hpp	/^  using typeTraitLDeriv = LDeriv;$/;"	t	struct:etr::BinaryType	typeref:typename:LDeriv	access:public
typeTraitLDeriv	Derivs.hpp	/^  using typeTraitLDeriv = LDeriv;$/;"	t	struct:etr::QuarternyType	typeref:typename:LDeriv	access:public
typeTraitO	helper.hpp	/^  using typeTraitO =$/;"	t	function:etr::colon
typeTraitObj	Derivs.hpp	/^  using typeTraitObj = Deriv;$/;"	t	struct:etr::UnaryType	typeref:typename:Deriv	access:public
typeTraitObj	unaryCalculations.hpp	/^  using typeTraitObj = I;$/;"	t	struct:etr::UnaryOperation	typeref:typename:I	access:public
typeTraitR	Derivs.hpp	/^  using typeTraitR = R;$/;"	t	struct:etr::QuarternyType	typeref:typename:R	access:public
typeTraitR	UtilsTraits.hpp	/^  using typeTraitR = std::remove_reference<decltype(convert(r))>::type::Type;$/;"	t	function:etr::defineMatrix
typeTraitR	binaryCalculations.hpp	/^  using typeTraitR = R;$/;"	t	struct:etr::BinaryOperation	typeref:typename:R	access:public
typeTraitRDeriv	Derivs.hpp	/^  using typeTraitRDeriv = RDeriv;$/;"	t	struct:etr::BinaryType	typeref:typename:RDeriv	access:public
typeTraitRDeriv	Derivs.hpp	/^  using typeTraitRDeriv = RDeriv;$/;"	t	struct:etr::QuarternyType	typeref:typename:RDeriv	access:public
varBorrow	Derivs.hpp	/^  std::array<Vec<BaseType, Borrow<BaseType>> *, NBorrow> varBorrow;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Vec<BaseType,Borrow<BaseType>> *,NBorrow>	access:public
varBorrowSEXP	Derivs.hpp	/^  std::array<Vec<BaseType, BorrowSEXP<BaseType>> *, NBorrowSEXP> varBorrowSEXP;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Vec<BaseType,BorrowSEXP<BaseType>> *,NBorrowSEXP>	access:public
varBuffer	Derivs.hpp	/^  std::array<Vec<BaseType, Buffer<BaseType>> *, NBuffer> varBuffer;$/;"	m	struct:etr::AllVars	typeref:typename:std::array<Vec<BaseType,Buffer<BaseType>> *,NBuffer>	access:public
vecTrait	subsetting.hpp	/^    using vecTrait = std::remove_reference<decltype(idx)>::type::TypeTrait;$/;"	t	function:etr::calcInd
vecTrait	subsetting.hpp	/^    using vecTrait = std::remove_reference<decltype(idxR)>::type::TypeTrait;$/;"	t	function:etr::calcInd
vector	helper.hpp	/^template <typename T> inline auto vector(T &inp) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(T & inp)
vector	helper.hpp	/^template <typename T> inline auto vector(const T &inp) {$/;"	f	namespace:etr	typeref:typename:auto	signature:(const T & inp)
walkT	Derivs.hpp	/^inline constexpr auto walkT() -> VariableType<T> {$/;"	f	namespace:etr	typeref:typename:VariableType<T>	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT() -> VariableType<T>;$/;"	p	namespace:etr	typeref:typename:VariableType<T>	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires (IsVec<T> &&!IsVariable<T>)auto	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires IsAddition<T> auto	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires IsMultiplication<TRaw> auto	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:requires IsSinus<T> auto	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT();$/;"	p	namespace:etr	typeref:typename:requires IsAddition<T> auto	signature:()
walkT	Derivs.hpp	/^inline constexpr auto walkT();$/;"	p	namespace:etr	typeref:typename:requires IsMultiplication<T> auto	signature:()
walkT	Derivs.hpp	/^template <typename T> inline constexpr auto walkT() {$/;"	f	namespace:etr	typeref:typename:auto	signature:()
warn	UtilsTraits.hpp	/^inline void warn(bool inp, std::string message) {$/;"	f	namespace:etr	typeref:typename:void	signature:(bool inp,std::string message)
whichType	subsetting.hpp	/^      using whichType = std::remove_reference<decltype(idx)>::type::Type;$/;"	t	function:etr::calcInd
whichType	subsetting.hpp	/^      using whichType = std::remove_reference<decltype(idxR)>::type::Type;$/;"	t	function:etr::calcInd
~BaseStore	UtilsTraits.hpp	/^  ~BaseStore() {$/;"	f	struct:etr::BaseStore	access:public	signature:()
~Borrow	UtilsTraits.hpp	/^  ~Borrow() {}$/;"	f	struct:etr::Borrow	access:public	signature:()
~BorrowSEXP	UtilsTraits.hpp	/^  ~BorrowSEXP() {$/;"	f	struct:etr::BorrowSEXP	access:public	signature:()
~Subset	UtilsTraits.hpp	/^  ~Subset() {}$/;"	f	struct:etr::Subset	access:public	signature:()
